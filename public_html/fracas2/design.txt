Fracas II: The Frackening

Implementation design

index.html
Initializes canvas, creates a Fracas2 instance, and starts it up.

Fracas2
This is the topmost class. It controls the top state machine. States:
1) Pregame
2) Gameplay(level) including brief Game Over

PreGame UI
Some kind of attract mode, with instructions and a start button I guess.

Level Pre-loading
Each level is a text file fetched over XHR. There's a level list with URLs. Fetch level 1 from pregame,
and 2 from 1, 3 from 2, etc, so they're ready. But don't assume they'll be ready when needed. Level switching
should always be async.

Level Playing
Here's the fun part.
It takes a canvas, a level map, and player stats (health, weapons, etc. if any)
It creates a webgl context, programs, webaudio context, etc...
Next steps:
Create a World object from the level.
Create triangle buffers from the static parts of the level (walls mostly)

Async Style
To render any WebGL, I need to load my renderer and shader,
then compile them into a program, and pass that to the renderer.
To play a level, I need to load its text representation.
Once the level is loaded, and the renderer is initialized,
I need to fill the renderer's background triangle vertex buffers.

So there's an implied graph of task deps.
Maybe the simple thing to do is to use the invalidate() function to move state fwd. Yeppers, that's simple.


3D Typeface "Sticks" - letters and numbers (and punctuation) made from cuboids.
How to express a cuboid (a 3D rectangle)?
I need it for rendering. I know how to render one from two GL triangle fans.
I can have a GLModel class that has a collection of points & colors, and knows how to draw
them - it knows if it's triangles or fans or whatever, and how it's organized.
It also has some standard point-manipulation... Best yet, it should support adding.
So if I have a cylinder, a cone, and a bunch of cuboids, I can combine those to make
a little rocket with arms and legs.
But... I kinda like more vertical integration, so I can have shaders for specific
objects or classes of objects, which take custom uniforms.
Although, if each GLModel is responsible for its own drawArrays(), then each one
can provide uniforms, too, to control shader behavior each frame.
OK, lets not worry about minimizing GL calls right now. Each GLModel
can have a list of draw commands, where each command has...
* vertex positions, Vec4 instances
* vertex colors, which I guess can also be Vec4
* drawArrays mode: LINES, LINE_STRIP, POINTS, TRIANGLE, TRIANGLE_FAN, etc.
  That way, adding another model just appends to arrays for the same mode.
* Uh that's it. No special uniforms-handling or anything. That can be handled
  by wrappers and stuff.
* Methods for transforming points and colors.
* Methods for adding one model to another, to build stuff.
Maybe I should learn indexed drawing and only use triangleseeessss? hm
I'll try indexed drawing with all triangles, and see how that goes.
Q: If this is cave2d.com, with "2D" in the title, shouldn't I stick to 2D?
I could do the same thing, but with rects instead of cuboids?
Or should I keep just a hint of 3D in there, for programmer fun and to make
the whole thing feel a little more... special? Hm.


Animation in Hardware
I could give each vertex two position values, and make the vertex shader interpolate
between them using a "time" uniform. It could be smooth or jumpy, depending on the time values.
Or they could animate based on multiple attributes and multiple uniforms.
That would make it possible to animate a gnome's limbs separately, and face and
hat and eyes too. They could have a walking-distortion, an excited-distortion,
a birth-distortion, and an death-distortion. Though I'd like to do a Robotron-style
death explosion, with the model stretching and distorting briefly.
