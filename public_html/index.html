<!doctype html>
<html>
<head>
<title>cave2d</title>
<style>
body {
  font-family: verdana, arial, sans-serif;
}

h1 {
  font-size:x-large;
  margin:1.2em 0 0.5em;
}

h2 {
  font-size:large;
}

h3 {
  font-size:medium;
}

a {
  font-weight:bold;
  text-decoration:none;
}

div {
  margin-top: 1em;
  margin-bottom: 1em;
}

</style>
</head>
<body>

I'm working on a 2D HTML5 game engine for phones, tablets and laptops.<br>
Source code: <a href="https://github.com/aaronwhyte/cave2d">github.com/aaronwhyte/cave2d</a><br>
Updates: <a href="https://plus.google.com/+Plexode/posts" rel="publisher">Google+ page for plexode</a>

<h1><a href="fracas2">Fracas II: The Frackening (currently broken)</a></h1>
This game is a sequel to my first-ever JS game, <a href="http://plexode.com/fracas">Fracas</a>,
which was based on an 8-bit Atari game, <a href="https://www.google.com/#q=Dandy%20Dungeon">Dandy Dungeon</a>.

<h1>Sound</h1>

<h2><a href="test26">Test 26 - Soundboard (work in progress)</a></h2>
With clickable ButtonSpirits - that's a new feature, darling.

<h2><a href="test25">Test 25 - Basic Sounds</a></h2>
Simple sound effects when stuff happens.<br>
And if you want to make your computer get hot: <a href="test25b">Test 25b - Basic Sounds x100</a>

<h1>More Graphics</h1>
<h2><a href="test24">Test 24 - Pointer</a></h2>
Use the touchscreen or mouse to point at stuff in the world.<br>
Tests the mapping from screen coordinates to world coordinates.

<h2><a href="test23">Test 23 - Printer</a></h2>
Easy WebGL text rendering is working now. Once everything is set up, it's<br>
<code>printer.printLine(startMatrix, nextCharMatrix, "DONKEY BATS");</code>
<p>
Here's some text, above a waving asteroid field that intersects rose-colored towers.

<h2><a href="test22">Test 22 - Renderer</a></h2>
Draws ModelStamps with a standard Renderer class, loaded with a RendererLoader.

<h2><a href="test21">Test 21 - Planet X</a></h2>
Tests sphere-building, and distortion.

<h2><a href="test20">Test 20 - Glyphs</a></h2>
Builds a whole alphabet in 3D.

<h2><a href="test19">Test 19 - F in 3D</a></h2>
Builds a model out of sub-models.

<h2><a href="test18">Test 18 - Twirling ghostly obelisks</a></h2>
Tests cuboid models.

<h2><a href="test17">Test 17 - A writhing sea of gnome hats</a></h2>
Tests RigidModel and ModelStamp, tools for building and rendering models.

<h2><a href="test16">Test 16 - Explosions</a></h2>
I just replaced every circle with an explosion, to work on explosions.

<h2><a href="test15">Test 15 - WebGL Renderer</a></h2>
This re-implements the twin-stick shooter renderer from tests 11-13, using WebGL instead of 2D canvas. WebGL
seems to be the key to smooth animation on an iPad 2 running iOS 8 - 2D canvas wasn't fast enough.
On Android, Chrome and Firefox are buttery smooth on Nexus 5 and 7, KitKat and Lollipop, Chrome and Firefox.
<p>
Here are some <a href="test15/notes.html">notes about rendering foregrounds and backgrounds in WebGL</a>,
based on what I learned from making test15.

<h2><a href="test14">Test 14 - Basic WebGL</a></h2>
A rectangle and a triangle, from <a href="http://learningwebgl.com/blog/?p=28">learningwebgl.com, Lesson1</a>,
plus some badly-coded animation.

<h2><a href="test13">Test 13 - Separate Physics and Drawing Speeds</a></h2>
In this test, the game oscillates between slow-motion and fast-motion every few seconds.
It's smooth and fast on Android, but still a little choppy on an iPad 2 with iOS 8. :-(
<p>
The physics engine has a single queue, sorted by time, to keep track of most events that affect the world:
<ul>
  <li>a body enters a grid cell</li>
  <li>a body exits a grid cell</li>
  <li>two bodies collide</li>
  <li>a spirit timeout fires</li>
</ul>
World-time is independent from JavaScript's <code>Date.now()</code>. To advance world-time, a client needs to
consume events from the queue, in time order. That usually causes more events to be inserted at later world-times.
<p>
Bodies don't have a currentPosition field. A body has a "path", where position is a function of time, calculated
using these fields:
<ul>
  <li>some starting position along a linear path
  <li>the time at which the body was at that start position
  <li>the body's velocity
</ul>
This path only changes when a body accelerates or teleports.
<p>
This all makes it easy to separate the speed of world-time from the rendering rate.
<p>
Also, in all previous tests, I was guilty of many of the anti-patterns in
<a href="http://games.greggman.com/game/webgl-anti-patterns/">http://games.greggman.com/game/webgl-anti-patterns/</a>.
I had made my canvas fullscreen by using a <code>window.onresize()</code> handler to set <code>canvas.width</code>,
<code>canvas.height</code>, <code>canvas.style.width</code>, and <code>canvas.style.height</code> to the same value as
<code>window.innerWidth</code> and <code>window.innerHeight</code>.
<p>Now test13 uses CSS <code>width:100%</code> and <code>height:100%</code> for the fullscreen effect, so those
never need to be adjusted by JS.
And every frame, test13 compares <code>canvas.clientWidth</code> to <code>canvas.width</code> (ditto for height), to
decide when to update <code>canvas.width</code> and <code>canvas.height</code>.

<h2><a href="test12">Test 12 - Canvas layers</a></h2>
This is the same as test11, but now the background (the walls) is painted once onto a separate canvas that is bigger
than the screen, and that canvas is moved, but not redrawn.

<h1>Controls</h1>
<h2><a href="test11">Test 11 - Stick Controls</a></h2>
Twin-stick shooter demo, to test a bunch of "Stick" control classes.<br>
Move with WASD keys, or the left half of a touchscreen.<br>
Fire using IJKL, arrow keys, a mouse or trackpad (using
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Pointer_Lock_API">Pointer Lock API</a>),
or the right half of a touchscreen.

<h1>Physics</h1>
<div><a href="test10">Test 10 - Rayscan</a><br>The RayscanSpirit uses rayscans to see and make decisions.</div>
<div><a href="test9">Test 9 - Spirit</a><br>"Spirit" classes animate bodies, bringing them to life.</div>
<div><a href="test8">Test 8 - Collision</a><br>Continuous 2D collision detection between bodies shaped like axis-aligned rectangles and circles.</div>

<h1>Quadtrees</h1>
<div><a href="test7">Test 7 - QuadTreeGrid &amp; HallPainter</a><br>You can draw a cave map with a mouse or touchscreen.</div>
<div><a href="test6">Test 6 - QuadTree Moon</a><br>Demos quadtree editing by adding a circle and deleting a circle, at 60fps</div>

<h1>Graphics</h1>
<div><a href="test5">Test 5 - Timeshift</a><br>Shifts the subtree's time as a function of time. Draws a clock that makes random, uneven progress.</div>
<div><a href="test4">Test 4 - Scale</a><br>Changes the size of a drawing tree over time. Looks like a hungry hydra.</div>
<div><a href="test3">Test 3 - Rotate</a><br>Rotates the drawing tree over time. Looks like a wiggly sea creature.</div>
<div><a href="test2">Test 2 - Translate</a><br>Moves chunks of the drawing tree over time.</div>
<div><a href="test1">Test 1 - Line</a><br>Interpolates line endpoints over time.</div>


<script>
if (document.location.hostname.indexOf('cave2d.com') > -1) {
  (function (i, s, o, g, r, a, m) {
    i['GoogleAnalyticsObject'] = r;
    i[r] = i[r] || function () {
      (i[r].q = i[r].q || []).push(arguments)
    }, i[r].l = 1 * new Date();
    a = s.createElement(o),
        m = s.getElementsByTagName(o)[0];
    a.async = 1;
    a.src = g;
    m.parentNode.insertBefore(a, m)
  })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

  ga('create', 'UA-7758703-3', 'auto');
  ga('send', 'pageview');
}
</script>
</body>
</html>
