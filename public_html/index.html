<!doctype html>
<html>
<head>
<title>cave2d</title>
<style>
body {
  font-family: verdana, arial, sans-serif;
}

h1 {
  font-size:x-large;
  margin:1.2em 0 0.5em;
}

h2 {
  font-size:large;
}

h3 {
  font-size:medium;
}

a {
  font-weight:bold;
  text-decoration:none;
}

div {
  margin-top: 1em;
  margin-bottom: 1em;
}

</style>
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
<link rel="icon" href="favicon.ico" type="image/x-icon">
</head>
<body>

HTML5 experiments and game stuff, targetting phones, tablets, and laptops.<br>
Source code is at <a href="https://github.com/aaronwhyte/cave2d">github.com/aaronwhyte/cave2d</a><br>
Random screenshots and gifs sometimes on <a href="http://aaryte.tumblr.com/">aaryte.tumblr.com</a><br>

<!--
<h1><a href="fracas2">Fracas II: The Frackening (currently broken)</a></h1>
This game is a sequel to my first-ever JS game, <a href="http://plexode.com/fracas">Fracas</a>,
which was based on an 8-bit Atari game, <a href="https://www.google.com/#q=Dandy%20Dungeon">Dandy Dungeon</a>.
-->

<h1>Little games?</h1>
<h2><a href="game1">Game 1</a></h2>
Work in progress. This'll be a simple 2D arena/maze shooter, I think.<br>
Now it's a demonstration of basic combat and infinite digging.

<h1>Editor</h1>

<h2><a href="test36">Test 36 - Save and Load</a></h2>
When you pause the editor, the game is saved to a sharable URL, in a giant hash-fragment.
If you open a saved-game URL, it starts playing immediately.

<h2><a href="test35">Test 35 - Object Dragging</a></h2>
Now objects can be dragged around. Physics still applies, and the cave is still editable.

<h2><a href="test34">Test 34 - Terrain Dragging</a></h2>
Start with the cursor in a tunnel and drag into the earth to extend the tunnel.
Or start with the cursor over earth, and drag to make walls or fill in tunnels.
<p>
Listens for three kinds of triggers:
<ul>
  <li>Touchscreen button (only appears if there have been recent touch events)
  <li>Mouse buttons
  <li>Keyboard keys (the Z key in this case)
</ul>

<h2><a href="test33">Test 33 - Cursor</a></h2>
Move a cursor over a scrolling canvas of terrain and objects.<p>
There are lots of reasons to treat mice, trackpads, and touchscreens like trackballs, for cursor control.
<ul>
  <li>It unifies pointing and panning. There's no separate camera-moving gesture.
  <li>On touchscreens, your finger doesn't block your view of the thing you're pointing at.
  <li>The cursor is always visible, so it can show hover indicators.
  <li>Trackballs support flinging, braking, and fine control.
  <li><a href="game1">Game 1</a> uses the same trackball metaphor to control movement, so you can use the
  same gestures for playing and editing.
</ul>


<h1>Vertex shaders</h1>

<h2><a href="test32">Test 32 - Parameterized Distortion</a></h2>
Applies a bunch of shifting distortions at the same time.
Includes a position quantizer, a repulsor/attractor, and a wavy flower-ish distortion.<br>
I &lt;3 VERTEX SHADERS

<h2><a href="test31">Test 31 - Mesh Distortion</a></h2>
Creates a ring model using a triangle mesh, draws an bunch in a grid, and applies a single hard-coded distortion to
them while the camera rushes around all higgledy-piggledy.

<h1>User Interface</h1>

<h2><a href="test30">Test 30 - Trackball</a></h2>
Use a trackpad or touch screen to maneuver with precise, natural control. Inspired by Marble Madness,
Crystal Castles, and gay marriage <span style="white-space: nowrap">:-D</span>

<h2><a href="test29">Test 29 - Full Screen &amp; Pointer Lock</a></h2>
Let the user enter fullscreen mode from the title screen or the PAUSED screen. Fullscreen is supported on all
desktop browsers, and in Android, in Chrome and Firefox. Safari on iOS 8 doesn't support it yet.
<a href="http://caniuse.com/#search=fullscreen">caniuse.com/#search=fullscreen</a>
<p>
Request pointer lock when entering PLAYING screen. Exit pointerlock when leaving that screen.
Browsers always exit pointerlock when "esc" is pressed, so also re-request it if the user clicks the PLAYING screen.
Chrome and Firefox are the only
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/requestPointerLock#Browser_compatibility">desktop
browsers that support pointerlock</a> as of June 2015.

<h2><a href="test28">Test 28 - Multiple Screens</a></h2>
Until now, each test has had one global world, renderer, and event handler.
Now a Screen class encapulates those aspects, so a game can have multiple screens.
A main controller class coordinates between the screens, and helps handle transitions.
<p>
A game can use this to have a title screen, settings, levels and level transitions,
pause screen, "Game Over", "Victory", etc.

<h1>Sound</h1>

<h2><a href="test27">Test 27 - Sound Board</a></h2>
Tap the words to make noises.

<h2><a href="test26">Test 26 - Touch Tone</a></h2>
Tap the boxes to make noises.

<h2><a href="test25">Test 25 - Basic Sounds</a></h2>
Simple sound effects when stuff happens.<br>
And if you want to make your computer get hot: <a href="test25b">Test 25b - Basic Sounds x100</a>

<h1>More Graphics</h1>
<h2><a href="test24">Test 24 - Pointer</a></h2>
Use the touchscreen or mouse to point at stuff in the world.<br>
Tests the mapping from screen coordinates to world coordinates.

<h2><a href="test23">Test 23 - Printer</a></h2>
Easy WebGL text rendering is working now. Once everything is set up, it's<br>
<code>printer.printLine(startMatrix, nextCharMatrix, "DONKEY BATS");</code>
<p>
Here's some text, above a waving asteroid field that intersects rose-colored towers.

<h2><a href="test22">Test 22 - Renderer</a></h2>
Draws ModelStamps with a standard Renderer class, loaded with a RendererLoader.

<h2><a href="test21">Test 21 - Planet X</a></h2>
Tests sphere-building, and distortion.

<h2><a href="test20">Test 20 - Glyphs</a></h2>
Builds a whole alphabet in 3D.

<h2><a href="test19">Test 19 - F in 3D</a></h2>
Builds a model out of sub-models.

<h2><a href="test18">Test 18 - Twirling ghostly obelisks</a></h2>
Tests cuboid models.

<h2><a href="test17">Test 17 - A writhing sea of gnome hats</a></h2>
Tests RigidModel and ModelStamp, tools for building and rendering models.

<h2><a href="test16">Test 16 - Explosions</a></h2>
I just replaced every circle with an explosion, to work on explosions.

<h2><a href="test15">Test 15 - WebGL Renderer</a></h2>
This re-implements the twin-stick shooter renderer from tests 11-13, using WebGL instead of 2D canvas. WebGL
seems to be the key to smooth animation on an iPad 2 running iOS 8 - 2D canvas wasn't fast enough.
On Android, Chrome and Firefox are buttery smooth on Nexus 5 and 7, KitKat and Lollipop, Chrome and Firefox.
<p>
Here are some <a href="test15/notes.html">notes about rendering foregrounds and backgrounds in WebGL</a>,
based on what I learned from making test15.

<h2><a href="test14">Test 14 - Basic WebGL</a></h2>
A rectangle and a triangle, from <a href="http://learningwebgl.com/blog/?p=28">learningwebgl.com, Lesson1</a>,
plus some badly-coded animation.

<h2><a href="test13">Test 13 - Separate Physics and Drawing Speeds</a></h2>
In this test, the game oscillates between slow-motion and fast-motion every few seconds.
It's smooth and fast on Android, but still a little choppy on an iPad 2 with iOS 8. :-(
<p>
The physics engine has a single queue, sorted by time, to keep track of most events that affect the world:
<ul>
  <li>a body enters a grid cell</li>
  <li>a body exits a grid cell</li>
  <li>two bodies collide</li>
  <li>a spirit timeout fires</li>
</ul>
World-time is independent from JavaScript's <code>Date.now()</code>. To advance world-time, a client needs to
consume events from the queue, in time order. That usually causes more events to be inserted at later world-times.
<p>
Bodies don't have a currentPosition field. A body has a "path", where position is a function of time, calculated
using these fields:
<ul>
  <li>some starting position along a linear path
  <li>the time at which the body was at that start position
  <li>the body's velocity
</ul>
This path only changes when a body accelerates or teleports.
<p>
This all makes it easy to separate the speed of world-time from the rendering rate.
<p>
Also, in all previous tests, I was guilty of many of the anti-patterns in
<a href="http://games.greggman.com/game/webgl-anti-patterns/">http://games.greggman.com/game/webgl-anti-patterns/</a>.
I had made my canvas fullscreen by using a <code>window.onresize()</code> handler to set <code>canvas.width</code>,
<code>canvas.height</code>, <code>canvas.style.width</code>, and <code>canvas.style.height</code> to the same value as
<code>window.innerWidth</code> and <code>window.innerHeight</code>.
<p>Now test13 uses CSS <code>width:100%</code> and <code>height:100%</code> for the fullscreen effect, so those
never need to be adjusted by JS.
And every frame, test13 compares <code>canvas.clientWidth</code> to <code>canvas.width</code> (ditto for height), to
decide when to update <code>canvas.width</code> and <code>canvas.height</code>.

<h2><a href="test12">Test 12 - Canvas layers</a></h2>
This is the same as test11, but now the background (the walls) is painted once onto a separate canvas that is bigger
than the screen, and that canvas is moved, but not redrawn.

<h1>Controls</h1>
<h2><a href="test11">Test 11 - Stick Controls</a></h2>
Twin-stick shooter demo, to test a bunch of "Stick" control classes.<br>
Move with WASD keys, or the left half of a touchscreen.<br>
Fire using IJKL, arrow keys, a mouse or trackpad (using
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Pointer_Lock_API">Pointer Lock API</a>),
or the right half of a touchscreen.

<h1>Physics</h1>
<div><a href="test10">Test 10 - Rayscan</a><br>The RayscanSpirit uses rayscans to see and make decisions.</div>
<div><a href="test9">Test 9 - Spirit</a><br>"Spirit" classes animate bodies, bringing them to life.</div>
<div><a href="test8">Test 8 - Collision</a><br>Continuous 2D collision detection between bodies shaped like axis-aligned rectangles and circles.</div>

<h1>Quadtrees</h1>
<div><a href="test7">Test 7 - QuadTreeGrid &amp; HallPainter</a><br>You can draw a cave map with a mouse or touchscreen.</div>
<div><a href="test6">Test 6 - QuadTree Moon</a><br>Demos quadtree editing by adding a circle and deleting a circle, at 60fps</div>

<h1>Graphics</h1>
<div><a href="test5">Test 5 - Timeshift</a><br>Shifts the subtree's time as a function of time. Draws a clock that makes random, uneven progress.</div>
<div><a href="test4">Test 4 - Scale</a><br>Changes the size of a drawing tree over time. Looks like a hungry hydra.</div>
<div><a href="test3">Test 3 - Rotate</a><br>Rotates the drawing tree over time. Looks like a wiggly sea creature.</div>
<div><a href="test2">Test 2 - Translate</a><br>Moves chunks of the drawing tree over time.</div>
<div><a href="test1">Test 1 - Line</a><br>Interpolates line endpoints over time.</div>


<script>
if (document.location.hostname.indexOf('cave2d.com') > -1) {
  (function (i, s, o, g, r, a, m) {
    i['GoogleAnalyticsObject'] = r;
    i[r] = i[r] || function () {
      (i[r].q = i[r].q || []).push(arguments)
    }, i[r].l = 1 * new Date();
    a = s.createElement(o),
        m = s.getElementsByTagName(o)[0];
    a.async = 1;
    a.src = g;
    m.parentNode.insertBefore(a, m)
  })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

  ga('create', 'UA-7758703-3', 'auto');
  ga('send', 'pageview');
}
</script>
</body>
</html>
