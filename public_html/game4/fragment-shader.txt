// Special rendering type:
// 0: none
// 1: circle cut-off
uniform lowp int uType;
uniform lowp float uTime;

uniform lowp int uCircleCount; // 1 to 8
uniform lowp vec3 uCircles[8];

varying lowp vec4 vColor;
varying lowp vec2 vPosReal;
varying lowp vec2 vPosWarped;

uniform lowp int uTexture;

int TEXTURE_NONE = 0;
int TEXTURE_WALL = 1;

void main(void) {
  if (uType == 0) {
    gl_FragColor = vColor;
  } else if (uType == 1) {
    lowp float minDist = 1.0;
    for (int i = 0; i < 8; i++) {
      if (i < uCircleCount) {
        lowp vec3 circle = uCircles[i];
        lowp vec2 circlePos = circle.xy;
        lowp float circleRad = circle.z;
        minDist = min(minDist, distance(vPosWarped, circlePos) / circleRad);
      }
    }
    if (minDist < 0.87) {
      gl_FragColor = vColor;
    } else if (minDist < 1.0) {
      gl_FragColor = vColor * 0.6;
    } else {
      discard;
    }
  }

  if (uTexture == TEXTURE_WALL) {
    lowp float s = 0.5;
    lowp vec2 fc = vec2(
        floor((vPosReal.x) / s + 0.5) * s,
        floor((vPosReal.y) / s + 0.5) * s);
    lowp float t = 0.1;
    lowp float meh = sin(uTime / 2000.1 + fc.x * fc.y * 1000.0)
               + cos(sin(uTime / 1000.0 + (fc.x * fc.y - 20.0 * fc.y) * 110.0)) - (2.0 - t);
    if (meh > 0.0) {
      //gl_FragColor.x += meh / t;
      gl_FragColor.y += meh / t;
      gl_FragColor.z += meh / t;
    }
  }
}
