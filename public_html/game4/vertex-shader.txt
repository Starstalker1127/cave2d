// Special rendering type:
// 0: none
// 1: circle cut-off
// 2: polyline
uniform lowp int uType;

uniform highp float uTime;

uniform mat4 uViewMatrix;
uniform mat4 uModelMatrix;
uniform mat4 uModelMatrix2;
uniform vec4 uModelColor;

// A circular buffer with alternating x and y values
const int POLY_LINE_DATA_LENGTH = 40 * 2;
uniform float uPolyLineData[POLY_LINE_DATA_LENGTH];
uniform int uPolyLineHeadIndex;
uniform int uPolyLinePointCount;

uniform int uWarpType[8];
uniform vec4 uWarpData[8];

attribute vec4 aVertexPosition;
attribute vec4 aVertexColor;
attribute lowp float aVertexGroup;

varying lowp vec4 vColor;
varying mediump vec2 vPosReal;
varying mediump vec2 vPosWarped;


void main(void) {
  if (uType == 0 || uType == 1) {
    // normal mode or circle-clip mode - they're the same for the vertex shader
    if (aVertexGroup == 0.0) {
      gl_Position = aVertexPosition * uModelMatrix;
      vPosReal = (aVertexPosition * uModelMatrix).xy;
    } else {
      gl_Position = aVertexPosition * uModelMatrix2;
      vPosReal = (aVertexPosition * uModelMatrix2).xy;
    }

    vec2 distort = vec2(0, 0);

    for (int i = 0; i < 8; i++) {
      int warpType = uWarpType[i];
      vec4 warpData = uWarpData[i];
      vec2 warpPos = warpData.xy;

      if (warpType == 1) {
        // repel
        float vertDist = distance(gl_Position.xy, warpPos);
        float warpRad = warpData[2];
        if (vertDist <= warpRad && vertDist > 0.0) {
          float strength = warpData[3];
          float repelMagnitude = max(-1.0, (warpRad - vertDist) * strength / vertDist);
          distort += (gl_Position.xy - warpPos) * repelMagnitude;
        }

      } else if (warpType == 2) {
        // quantize
        float vertDist = distance(gl_Position.xy, warpPos);
        float warpRad = warpData[2];
        if (vertDist <= warpRad && vertDist > 0.0) {
          float chunk = warpData[3];
          distort += floor((gl_Position.xy - warpPos) * chunk + vec2(0.5, 0.5)) / chunk - gl_Position.xy + warpPos;
        }

      } else if (warpType == 3) {
        // flower
        float vertDist = distance(gl_Position.xy, warpPos);
        vec2 tip = vec2(warpData[2], warpData[3]);
        float warpRad = length(tip);
        if (vertDist <= warpRad && vertDist > 0.0) {
          float angle = atan(tip.y, tip.x) - atan(warpPos.y - gl_Position.y, warpPos.x - gl_Position.x);
          vec2 unit = (gl_Position.xy - warpPos)/warpRad;
          distort += 0.5 * warpRad * unit * (0.5 + (0.5 - vertDist/warpRad)) * sin(angle*7.0);
        }

      } else if (warpType == 4) {
        // invert circle
        float circleSize = warpData[2];
        float vertDistFrac = distance(gl_Position.xy, warpPos) / circleSize;
        vec2 relPos = gl_Position.xy - warpPos;
        if (vertDistFrac > 0.0) {
          vec2 newRelPos;
          if (vertDistFrac < 1.0) {
            newRelPos = circleSize * relPos / length(relPos);
          } else {
            newRelPos = relPos / (vertDistFrac * vertDistFrac);
          }
          distort += newRelPos - relPos;
        }
      }
    }
    gl_Position.xy += distort;
    vPosWarped = gl_Position.xy;
    gl_Position *= uViewMatrix;

  } else if (uType == 2) {
    gl_Position = aVertexPosition;
    // polyline mode!
    int pointNum = int(gl_Position.z);
    int p0Index = uPolyLineHeadIndex - 2 * pointNum;
    if (p0Index < 0) {
      p0Index += POLY_LINE_DATA_LENGTH;
    }
    int p1Index = uPolyLineHeadIndex - 2 * (pointNum + 1);
    if (p1Index < 0) {
      p1Index += POLY_LINE_DATA_LENGTH;
    }

    float yOff = gl_Position.y;
    if (gl_Position.x < 0.0) {
      // p0
      gl_Position.y = uPolyLineData[p0Index];
      gl_Position.x = uPolyLineData[p0Index - 1];
    } else {
      // p1
      gl_Position.y = uPolyLineData[p1Index];
      gl_Position.x = uPolyLineData[p1Index - 1];
    }
    gl_Position *= uModelMatrix;
    gl_Position.z = 0.99;
    gl_Position.y += yOff * 1.5;
    gl_Position *= uViewMatrix;
  }

  vColor = aVertexColor * uModelColor;
}
