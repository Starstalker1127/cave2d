2015-10-17
Mutable Terrain with BitGrid
v Nigh-infinite grid of cells
v drawPill
v getDirtyCells
v clearDirtyCells
v compress rects

2015-10-25
Game logic for mutable, explorable, yet limited terrain, v1.
All bodies will always be in memory, and all models will be in GL, but we'll only draw visible models.
v Load all dirty wall cells after level creation, and all adjacent uniform wall cells, so we get no gaps adjacent to
  dirty cells.
  v get x,y from cellId
v push-scroll camera - drag it so focal object (player body for now) is never more than X world dist away from camera.
v Draw each cell separately
  v Have separate GL models for every non-uniform cell.
    v cell def
      v BitGrid cellId
      v body id array (or null if bodies weren't loaded)
      v private GL model handle, or null if none
  x Use one model for uniform cells.
  x Draw solid cells that have no bodies? Or draw floor cells only? Kinda digging the floor idea.
v Draw every cell on the screen, and a little more for shader-distortion padding, but no more.
v mutation: unload and reload any loaded cells that change, and doublecheck adjacent cells.
  v Make bullets destroy terrain, to test mutation
Done 2015-10-28

Fix WorldEvent memory leak? Is it infinite-duration paths clogging up the event queue?
Nope. The problems were:
1) Tiny world cells probably sucked
2) Double-adding bodies when terrain changed was certainly bad.
3) Walls were declared to collide with themselves, which was wrong.
4) The event queue had events with times of Infinity. Good luck with that.
Done 2015-10-28 but nearly 24 hours later.

Cursor
v Set up new test33, with game1's tech mostly.
v Cursor movement: Same as game1 player, sans body (probably) and without worrying about collisions.
v Camera control: Also same as game1 player. (Hm. Extract common logic?)
v Hover detection and indicator
  v Render a ring
    v sweet sweet alpha blending
  v different cursor styles for each mode.
  v world.getOverlaps(body) returns list of bodies
  v Hover mode - what are we pointing at?:
    v pinpoint center check
      v if objects overlap, pick the one with the smallest area
      v Centered on wall block: WALL mode
    x broader check, objects only
      x If there are any, take the one with the lowest distance-to-surface.
    v finally, FLOOR mode
v Tweak cursor acceleration curves until it feels right.
Even more done, 2015-11-03

Trigger
v test34, copy of test33
v multitrigger
  v regular trigger
  v keytrigger
  v touchtrigger
  v add invisible touch trigger and key trigger to multitrigger and see if it goes.
    v multi keys down/up separately and are ORed together
    v unlisten works
    v touch trigger blocks touch trackball from eventing. order of add? zone function sharing?
v Use trigger in test for terrain editing.
  v triggerDown with wall/floor indicator starts floor/wall initial position, draws first pill.
  v drawPill from old to new position, then let old=new.
  v triggerUp ends it
v draw touchscreen trigger
  v circle on viewport coords, not world coords.
  v only draw if there have been touch events in the last N seconds.
v Handle rotation/resize...
  v Track trigger pos as fraction of screen width/height, 0..1
  v Start at 0.9, 0.9
v Add trigger to game1 - no more auto-firing.
Done 2015-11-09

Drag objects
You can drag things by applying force to them in the world, or you can simply lift them out of the world and relocate
them.
v test35 exists
v Put objects in the tunnel parts.
v Dragging applies force to objects to accelerate them towards the cursor.
  v Remember model-coord grip point
  v adjust force to be proportional to object's mass.

v Fix BitGrid "sudden square" bug. Easy to repro with KeyTrackball in test35.

Arrow key trackball, for those poor bastards using IE or Safari.
v game1
v test35
v test34
v test33
v test30

Better Ring Renderer and more
* for indicators, explosions, and stuff.
- For each vertex, say which model transformation number it should use.
- Multiple model transformations - an array.

Zoomable
- two-touch pinch/unpinch
- mouse onscroll, like Vorp
- keys, maybe "[" and "]" or "," and "."

Separate trigger for object grabbing
- actual Trigger
- separate object hover indicator from terrain indicator, make it grabbier
  - use new Ring renderer to keep the ring width proportional to the view size.

Non-pointerlocked mouse UI, perhaps direct-touch UI too?


- Lifting
  - If cursor distance is too great for too long (low-pass average dist?), "lift" the object
  - Lifted objects are treated as though they are uniform density, normal MOI, with no physics or collisions.
  - Can lifted objects be sensed with rayscans? No, they're transferred to the "none" group.
  - Only one object can be lifted at a time (worry about multi-user in the distant future).
  - Lifting ends when you release the object.
  * When time is frozen (upcoming feature), all object-movement is by lifting, because there is no time for physics.
  * When adding objects, they are lifted as they leave the menu.
- Alter orientation
  - Bodies have orientation and a moment of inertia.
  - Force can rotate bodies


Add & delete objects
- Add action, menu... oh no, menus!
- Deletion pseudomode

Save and load from string
- terrain: BitGrid s27n
- bodies
- spirits
- time, timeouts

Particles
- test page - fireworks?
- game1 every kind of explosion
- game1 muzzle flash

Zoomable UI
- Scrollwheel zooms between some fixed zoom levels
- Touching the zoom indicator buttons zooms to that level Maybe four: close, medium, wide, far.
