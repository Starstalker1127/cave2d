2014-03-22
Resizing Canvas - just for one page.
v window measurement
v resize event listener
v canvas resizer
v put it in cave2d site

2014-04-28
Viewport and camera
v viewport has resize callback
v camera has pan, rot, and zoom
v works w test page


2014-05-08
Some nodes...
line node {
  series:[{t, pa, pb}, {t, pa, pb}...] sorted by t.
  startTime: t, or default to series[0].t
  endTime: t or infinity or series
}
translate node {
  series:[{t, pos}+] sorted by t.
  startTime: t, or default to series[0].t
  endTime: t or infinity
}
rotate node {
  series:[{t, rads}+] sorted by t.
  startTime: t, or default to series[0].t
  endTime: t or infinity
}
scale node {
  series:[{t, scale}+] sorted by t.
  startTime: t, or default to series[0].t
  endTime: t or infinity
}
// zomg the power of the series! Slomo, fastmo, reverse, scratch...!
delay node {
  series:[{t, delay}+] sorted by t
  startTime: t, or default to series[0].t
  endTime: t or infinity
}

2014-07
Basic Nodes
v line
  v one whirly hexagon
v translate
  v two moving whirly hexagons
    v tree traversal is automatic
    v basenode works as collection of subnodes
    v subgraph reuse works
v rotate
  v wiggly arms demo
v scale
  v other wiggly arms demo
v delay
  v shifty clock demo

DONE Milestone: Animated canvas thingy with variable speed time
========================================================================

2014-07-13
QuadTree and demo
v basic quad
v color with a shape (circle?)
v demo

Quadtree Grid
v edit like a quadtree
v serialize & deserialize
  v port bit manipluation
    v bitqueue
      v test
    v base64
  v quadtree s27n
    v ser
    v des
    v test
  v quadtreegrid s27n
    v ser
    v des
    v test


Editor Improvements
v Only redraw a dirty rect, or a list of affected quadrants.
v Mouse support
v Hall Pills: Affect the space between to events connected by dragging - update HallPainter,
and capture drags in event handling code.
  v dist from segment to point
  v drag tracking
  v proper hall pill painter

v Simple AABB rect object, like vec2d.

#### MILESTONE: Nice editable mazes, for mouse and touch
#### COMPLETE
What I learned:
* Quadtrees are cute but kind of a pain in the A too because they're not a simple grid.
* The system of void/wall/floor drawing is good. Keep it.
* Multi-gesture+mouse drawing-based map editing is really great, and I want to keep that.
* Turns out the Vorp code isn't as easy to reuse and adapt as I'd hoped.

Now it's time to rewrite the physics & gameplay engine, to be easier to understand and use.

Body
* Used by the internal collider to enqueue future events.
* Used by the internal default collision response code.
* Used by Sprites, through a careful API which handles pathId invalidation.
v Identity
  v id
  v spiritId or 0
v Path
  v pathId - changes whenever a trajectory field changes. 0 means it's invalid.
  v pathStartTime - just for calculating position as func of time
  v pathStartPos
  v vel
  v pathEndTime - for not looking ahead too far, if acceleration is scheduled.
v Shape (affects path)
  v shapeType (circle or rect)
  v rad (for circles)
  v radX (for rects)
  v radY (for rects)
v hitGroup (changing invalidates path. Probably changes infrequently.)
v mass
v elasticity
v getPosAtTime(t, out)
v getBoundingRect(t, out)
v set pos & vel
v alloc & free
I'm trying to be uncompromising: Don't create an object field pointing to a parent. Pass the parent in to methods.

Spirit baseclass
A spirit subclass can have lots of custom logic, scheduling, sensing, body-manipulation, etc.
v id
v world event handlers: start, timeout, hit
x bodyIds? Or just methods that take lists of bodies, and single bodies?

World (but not all its collider aspects)
v spirits {id: spirit}
v bodies {id: body}
v pathIdToBody {id: body}
v world's spirit-facing API:
  v addBody
  v removeBody
  v getBody
  x setTimeout
  x cancelTimeout
  (later: rayscans)
v getBodyByPathId purges obsolete pathId keys

How will path invalidations get buffered up for when the World needs to move time forward?
Easy way is to make each Body hold World, like a parent pointer. I tried to avoid it but maybe I can't.
It's cleaner to include the PathInvalidator in each Body, and the World, like Vorp does. Sigh, OK.

Start Test 8 - A World
v Simple renderer
  v draw bodies
  v viewport surrounds everything automatically
    v do it body-by-body for now, until cells exist

Event Queue, and Time.
The world has a big queue of events, in time order. Future events are predictions that may be invalidated by earlier
events.
The trick here is to separate the runtime order in which events are added, and the game-time order in which they
are dequeued and processed.
v init events: body entering cells
v init events: body exiting cells

DONE 2014-10-05
v add-to-cells
  v initial addBody add-to-cells
  v add-to-cell
    v add to group layer
    v add collision events
      v actual time-to-collision checking
        v brects
        v rect to rect (same as brects?)
        v circ to circ
        v circ to rect
        x unit test?
        x fix double-hit across cells? or no? Only happens on initial add, right?

Process the queue
v Process enter events
  v add to cells
  v create next entry event
v Process exit events
  v add next one
v Process collisions
  v default collision response
    v calc accel
      v circle/circle
      v circle/rect
      v rect/rect
    v alter paths
  v spirit callbacks
v Process collision v2
  v World only detects
  v Game uses resolver, or whatever, to handle hit events.

Timeouts:
v timeout event: spirit scheduled to do something, like accelerate, sense, react to something that happened earlier, etc.
  Scheduling things to happen at floating-point times is the key to making reflex-time important for NPCs

Cell collider
v sparse grid of cells
v cell
  v array mapping hitgroup index to list of pathIds
v map from bodyId to body
v map from pathId to body. (If a body has a different pathId, then the index one is invalid)
v body creation causes...
  v overlap tests & immediate hit events w bodies in cells
  v time-to-hit tests, events (multiple)
  v enter-cells test, event (zero or one) - bounding rect's leading point crosses a cell x or y line
  v exit-cells test, event (zero or one) - bounding rect's trailing point crosses a cell x or y line
v enter-cell event causes
  x overlap tests (maybe not?)
  v time-to-hit tests
  v enter-cells test for next edge or axis
v exit-cell test removes bodyId from departed cells

v Test 9: Bodies animated by a spirit, using timeouts

#### MILESTONE: fully functional physics for aarects and circles
#### STATUS: DONE 2014-10-12

Make a maze and play it.
Terrain URL
v port stuff
  v url
  v lempelziv
    v map
  v squisher
- button saves sharing URL to textarea
- button dismisses textarea
- onload parse URL

Game UI Nav
- list of levels
- start player with data D
- start editor with data D

Editor Skeleton
v screen-to-world trans
- nav/wall/air mode switch?
v pointer-based grid editing
  v circles at each event
  v touch
  v continuity between event points on drag
  v mouse
- drag-based panning

overlap
- rect/rect
- circ/circ
- rect/circ
- init events: body overlap
- draw overlaps and non-overlaps

