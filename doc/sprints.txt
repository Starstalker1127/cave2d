Game2 refactoring I
v pull up menuitemconfig to cave2d lib
v pull up spiritconfig to cave2d lib
v break up game2/basescreen a bit.
  * baseScreen won't be re-used, but it will be copied
  * some useful code can be extracted from it for true re-use
  * it can be made smaller and more template-y.
  v sounds as plugin
    v put sound effect code in it's own file
    v call screen.sounds.foo() - remove screen sound methods
      yeah yeah Law of Demeter... Adding a param to every Spirit is a PITA. Not gonna do it.
  v stamps as plugin
    v glyphs
    v generic shapes like "tube"
    x spirit config stamps?
    v replace uses, violate Law of Demeter, but mainly in reset() methods, where fields are extracted from screen obj
  v replace screenXXX.lazyInit
    v make it deliberate, not lazy
    v unpack calls into the pages that build screens
      v play
      v edit
      v test

Make basic app page-creation configurable.
v rename
  v LevelEditorPage to EditLevelPage
  v LevelTestPage to TestLevelPage
  v LevelPlayPage to PlayLevelPage
v Move to game2
  v EditLevelPage
  v TestLevelPage
  v PlayLevelPage
v EditorApp
  v inject EditLevelPage ctor
  v inject TestLevelPage ctor
v PlayApp
  v inject PlayLevelPage ctor

Game2 BaseScreen refactoring II
v generalize wall tile code: TileGrid yay!
x generalize level JSON deserislization logic
x generalize controls setup?
x generalize dom event handling (listen, unlisten, distributor setup)
x phy stuff
  x groups setup
  x collision handling
  x scan util

Test 39: Orientation & off-center force
v test nest based on previous editor tests
v Start over? nest based on game2 edit app?
v prepare nest
  v remove the multi-adventure multi-level bits. Just one level and adventure.
  v remove test switch
  v edit and play at the same time
v change spirits
  v remove exit
  v remove player
  v remove bullet
v body values
  v moi
  v "turnable" boolean? - default undefined means no?
  v angStart
  v angTime
  v angVel
  v getAngPosAtTime()
  v setAngPosAtTime()
  v setAngVelAtTime()
v make AntSpirit use new rotation system
v editor
  v grab objects at a point, and apply force to that point when dragging
    v point defined by dist & direction from center of mass.
  v give cursor a direction based on movement
  v add objects with initial orientation based on cursor direction
  v s27n

Surface collision grip
v calc contact point of collision
  v hitresolver stuff
  v game2 tweaks
v "surfaceGrip" in body
  * 0: frictionless, like a bowling ball
  * 0.3: fair amount of friction, like a dirty tire
  * 0.5: very grippy, a clean basketball
  * 1: 100% elastic, like a superball
  There are more realistic characterizations...
  A superball will grip a bowling ball and a wood floor
  but a bowling ball will not grip a wood floor
  so there's smoothness, stickyness, tread...
  there's also grip decrease as surface vel increases, like tires gripping vs slipping
  and grip is a function of pressure too. arrr
  Basically grip is a function of both surfaces, the surface velocity, pressure, hardness...
v collision response
  v calculate surface velocity vec
  v calc force to totally reverse surface vec
  v then mult by product of surface grips
  v apply those forces at edges of objects
  v really solve for force. Math works!
  v debug it. Energy is not being conserved?
    v end surface velocities will be ~equal if grip==1
    v energy conserved or reduced a little

chain constraints
Simple distance between two body positions - no offset from center, because rotation would make that harder.
- phy map from bodyId to chain constraint

Game 3: Stunt Tank!

Multiplayer
* up to four touch players
* Up to three keyboard players: wasd, ijkl, arrows
* Gamepad controls if possible
Player modes: Absent, Wispy, Embodied

process-ish level creation tools
- structured digging
- erosion
- accretion
- structured building


Test XX: Undo and Redo
- retain last N JSON serializations in RAM or wherevs.
- Create new ones using one-token-bucket throttle right before mutations, w 1/sec(realtime) restore rate.
- Always save the just-after mutation camera and cursor pos, to bring the area into focus before undoing.
  Keep that as a separate kind of undo record, since it's so tiny and easy to restore.
- Button for creating an undo record just because time went by. Snapshot?
- Keyboard support
- Touch support

Zoomable Editor
- two-touch pinch/unpinch
- mouse onscroll, like Vorp
- keys, maybe "[" and "]" or "," and "."
- Touching the zoom indicator buttons zooms to that level Maybe four: close, medium, wide, far.

Lifting?
- If cursor distance is too great for too long (low-pass average dist?), "lift" the object
- Lifted objects are treated as though they are uniform density, normal MOI, with no physics or collisions.
- Can lifted objects be sensed with rayscans? No, they're transferred to the "none" group.
- Only one object can be lifted at a time (worry about multi-user in the distant future).
- Lifting ends when you release the object.
* When time is frozen (upcoming feature), all object-movement is by lifting, because there is no time for physics.
* When adding objects, they are lifted as they leave the menu.
