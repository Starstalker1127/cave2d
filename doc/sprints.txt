2017-06-18

game4 nest
v take over old game4

reduce setScreenListening redundancy
v shrink testscreen's setScreenListening()
v ditto for playscreen
v repeat for all the play/test code that could use it throughout cave2d

2017-06-24

v testScreen inherits from playScreen, to de-dupe a lot of code.

game4 multiplayer controls
v controlName, controlState files
v create the 7 slots
  v study test45
  v page calls configurePlayerSlots() near initializing the world
  v screen.configurePlayerSlots()
    v models and stamps
      v models.glyphs
  v screen.handleInput()
    v slots
      v join
        v playerJoin(slot)
          v playerSpawn(slot)
      v drop
        v playerDrop()
    v PlayerSpirit.handleInput
      v unpack and use controls
      v make tractor beams work like test45
v Render the hud
v Add the mid-screen pause widget

2017-06-28

game4 multiplayer rendering
v zoom
v selective tile draw
v selective spirit draw
v shader for circle mask

Refactoring
v pull renderer up out of test44-45 and game4 and replace the main renderer
v standardize metrics, graphing code chunks
  v initStatMons
  v fields
    v statMons
      v leftStatMons
      v rightStatMons
      v drawLeftGraphs
      v drawRightGraphs
    v cuboids
      * add to CuboidRules
      v bottomRight
      v topRight
      v bottomLeft
      v topLeft
      v graphsCuboid
  v sampleStats - overridden from WorldScreen, called from page.animateFrame()
  v drawStats

v pull game4's splashes into a new file, like I did for "sounds" (done except for unused explosion biz)

v delete game4.getAveragePlayerPos and everything that uses it

v player death
  v explosion
    v at all
    v move to Splashes
  v respawn timeout start
  v respawn

v fix crash when beam target body vanishes

Game4 Basic Mechanics
v entrance 1
  v entrance spirit
    v config
    v editor-able
    v remove player from editor menu
  v zero players
    v camera at entrance
  v add player at entrance
  v respawn after death
    v death by critter
v exit 1: basic game2 biz
v useful objects & activation
  * based on "Vehicles" basic neuron model
  * Each target has one input port that accepts any number of simultaneous connections.
  * Input values are steady values that change discontinuously, in sudden steps.
  v data structures
    v Source maintains map from target spirit IDs to output values to those targets, in case source gets polled.
    v Target maintains set of source spirit IDs, for polling.
    v Target also maintains map from pulse input end time to pulse input value.
  v activation by linked spirit
    v api
      v targetSpirit.addInputSource(sourceSpiritId) // set output value first in case target reads it
      v targetSpirit.removeInputSource(sourceSpiritId)
      v targetSpirit.onInputChanged(sourceSpiritId, val)
      v sourceSpirit.getOutputToTarget(targetId)
      x world.isOutputInputPair(sourceId, targetId) // debugging only?
  v activation by pulse or ray
    v targetSpirit.addInputPulse(duration)
  v target polls inputs on events and timeouts (anything that could change values)
    v targetSpirit.sumOfInputs()
    v iterate through pulses, culling obsolete ones and adding valued from active ones
    v iterate through sources, culling or adding
  v exercise the system
    v player activates indicator light
      v indicator light spirit that just shows whether there's any input or not
        v basic spirit
        v add to editor menu
        v polls for activation during rendering
      v player tractor beam can activate target
        v wield adds source
        v unwield detaches it
        v activate sets val to 1
        v deactivate 0
      v whole thing works
    v player wielding/activating/ejecting twists things to point along wield vector
    v activator raygun that serves 2 purposes:
      v it is activation target, like the light
      v When activated, it fires activation bullets that can activate stuff like lights and other rayguns
        v activation bullet spirit
          v collision triggers activation pulse

Movement again...
v traction or responsive movement
v good slow aim precision

Bugs and cleaning
v Unlock mouse pointer when paused, relock on resume
v Activator gun fire schedule
  v use new timeout (don't re-use friction)
  v don't stop firing when off-screen
v higher friction/traction on all manipulable objects

x change Wield physics? (what did I have in mind??)

v entrance 2: done 2017-09-17
  * continuation of player slots - don't make players re-add themselves
  * "gameState"
  v app/PlayApp
    v exitLevel param
    v VictoryPage ctor param (not that it matters)
    v createPlayLevelPage param
    v playLevelPageCtor call param
    v restartLevel param
      v createPlayLevelPage param
  v app/ScreenPage
    v ctor param
    v field
  v game4/PlayLevelPage
    v ctor param
    v pass fresh value to this.app.exitLevel
      * have a way to create a fresh one!
      v game4PlayScreen.createGameState()
    v pass old value to this.app.restartLevel
    v use in maybeCreateScreen()
      x pass to Game4PlayScreen ctor I guess!
      v page explicitly restores state with Game4PlayScreen call
  v game4/Game4PlayScreen
    v createGameState() called from PlayLevelPage
      v list of players
        v slot names or whatever
        x color?
        x position relative to exit?
        x velocity relative to exit?
        x equipment (later!)
    v Populate slotNames when creating slots.
    v method for adding a player by slotName
  v Slots
    * need permanent serializable IDs
    v replace random slot.id with real names
  v Maintain pointerlock across levels

- death 2
  - fragment-view circle shrinks to nothing in-place
    * don't encourage dying to get extra info
    * slow enough to see how you died, fast enough to not be totally annoying.
  - ghost returns to spawn point
    - player gets ghost body? Maybe totally invisible non-body would be fine.
    - ghost pan/zoom camera circle doesn't affect shader during normal draw.
    - ghosts are drawn always - separate pass with different shader params so they don't get clipped out
    - touching spawn point restores solid player body, back to normal.

- beam shader
  - 2d mesh
  - params
    - endpoint positions
    - endpoint sizes
    - squash/stretch
    - wave magnitude, offset, and frequency

player kick
- control
  - instant, not sustained
  - some frequency limit
- physics
  - rayscan shotgun
  - mutual spring push
  or
  - actual repulsor shotgun
  - because then I can have repulsor turrents weee
- graphics
  - instant fan of overlapping splashes?
  - fast decay to pos slightly out of range
  - special splashes for hits

Effects
- pulse splashes
  - muzzle-flash when firing
  - 3-5 splash particles on wasted hit
  - cleaner flash on activation hit - circle? arrowhead? sparkles?
- fix weird noise when activator bullet hits player

- exit 2
  * all players must be present and relaxed to exit
  - players near exit are "exiting" - drawn in and spun around a bit
  - but players can leave exit zone if not all players are in it
  - when all players are in, actual exit process happens

- outfits?
- entrance 3
  - continuation of player equipment (?)
    (this is the real motive for making it to the exit, instead of dying and respawning. Plus honor I guess.)

