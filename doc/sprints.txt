2015-10-17
Mutable Terrain with BitGrid
v Nigh-infinite grid of cells
v drawPill
v getDirtyCells
v clearDirtyCells
v compress rects

2015-10-25
Game logic for mutable, explorable, yet limited terrain, v1.
All bodies will always be in memory, and all models will be in GL, but we'll only draw visible models.
v Load all dirty wall cells after level creation, and all adjacent uniform wall cells, so we get no gaps adjacent to
  dirty cells.
  v get x,y from cellId
v push-scroll camera - drag it so focal object (player body for now) is never more than X world dist away from camera.
v Draw each cell separately
  v Have separate GL models for every non-uniform cell.
    v cell def
      v BitGrid cellId
      v body id array (or null if bodies weren't loaded)
      v private GL model handle, or null if none
  x Use one model for uniform cells.
  x Draw solid cells that have no bodies? Or draw floor cells only? Kinda digging the floor idea.
v Draw every cell on the screen, and a little more for shader-distortion padding, but no more.
v mutation: unload and reload any loaded cells that change, and doublecheck adjacent cells.
  v Make bullets destroy terrain, to test mutation
Done 2015-10-28

Fix WorldEvent memory leak? Is it infinite-duration paths clogging up the event queue?
Nope. The problems were:
1) Tiny world cells probably sucked
2) Double-adding bodies when terrain changed was certainly bad.
3) Walls were declared to collide with themselves, which was wrong.
4) The event queue had events with times of Infinity. Good luck with that.
Done 2015-10-28 but nearly 24 hours later.

Cursor
v Set up new test33, with game1's tech mostly.
v Cursor movement: Same as game1 player, sans body (probably) and without worrying about collisions.
v Camera control: Also same as game1 player. (Hm. Extract common logic?)
v Hover detection and indicator
  v Render a ring
    v sweet sweet alpha blending
  v different cursor styles for each mode.
  v world.getOverlaps(body) returns list of bodies
  v Hover mode - what are we pointing at?:
    v pinpoint center check
      v if objects overlap, pick the one with the smallest area
      v Centered on wall block: WALL mode
    x broader check, objects only
      x If there are any, take the one with the lowest distance-to-surface.
    v finally, FLOOR mode
v Tweak cursor acceleration curves until it feels right.
Even more done, 2015-11-03

Trigger
v test34, copy of test33
v multitrigger
  v regular trigger
  v keytrigger
  v touchtrigger
  v add invisible touch trigger and key trigger to multitrigger and see if it goes.
    v multi keys down/up separately and are ORed together
    v unlisten works
    v touch trigger blocks touch trackball from eventing. order of add? zone function sharing?
v Use trigger in test for terrain editing.
  v triggerDown with wall/floor indicator starts floor/wall initial position, draws first pill.
  v drawPill from old to new position, then let old=new.
  v triggerUp ends it
v draw touchscreen trigger
  v circle on viewport coords, not world coords.
  v only draw if there have been touch events in the last N seconds.
v Handle rotation/resize...
  v Track trigger pos as fraction of screen width/height, 0..1
  v Start at 0.9, 0.9
v Add trigger to game1 - no more auto-firing.
Done 2015-11-09

Drag objects
You can drag things by applying force to them in the world, or you can simply lift them out of the world and relocate
them.
v test35 exists
v Put objects in the tunnel parts.
v Dragging applies force to objects to accelerate them towards the cursor.
  v Remember model-coord grip point
  v adjust force to be proportional to object's mass.

v Fix BitGrid "sudden square" bug. Easy to repro with KeyTrackball in test35.

Arrow key trackball, for those poor bastards using IE or Safari.
v game1
v test35
v test34
v test33
v test30

test35 better ring indicator
* for indicators, explosions, and stuff.
v For each vertex, say which model transformation group it belongs to.
  v Vertex.group, defaults to 0
  v RigidModel can create double-ring
  v ModelStamp can prepare to draw using group attribute
  v Renderer support for group attribute
v test35
  v vertex shader
  v Second model mat44 in PlayScreen
  v use new doubleRingIndicator
    v Ring indicator should be of uniform pixel-width, regardless of scale or object size.
x retrofit all previous vertex-shaders paired with Renderer.

Splashes 1
v Splash, with pooling
v Splasher
  v add splash
  v draw splashes, with auto-remove
v Game1 splashes
  v player trail
  v enemy destruct
  v wall destruct

Save and Load from squished JSON, part I
v test36 nest, based on test35
  v no multiple screens
  v no spaceFn
v BitGrid to/from JSON
  x done already in worst way
  v rad optimized quadtree bits, around 1/3 the size.
  v unit test a little
v pause button
  v support multiple triggers
    v grip trigger is not so special
    v "listeners" arraySet
    v RoundTouchTrigger
  v pause is a trigger
    v draw it
    v subtract it from trackball startRegion
  v pause trigger down toggles pause state
    v stop rendering/clocking loop
    x turn sound down (no sound yet)
    v deactivate/reactivate pointerlock
      v event stack listeners for triggers
        v trigger up/down pubsub
        v multitrigger only fires on change
      v handler in test36 playscreen
v paused menu
  v regular DOM, over the canvas
  v fullscreen button
  v create nest for sharable hyperlink
v nest for reading URL onload
  v read level from URL
  v create new level
v Make bitGrid save/load work in test36
  v save
  v load
v Fix performance bug: world goes slow when touch trigger is up, sometimes, and fast when it's down?
  * World cells were 64 times too big by area, and there was an n^2 overlap check algorithm, so O(1000^2) per frame!
v World to/from JSON I
  v now
    v save
    v load
  v Bodies
    v save
      v Serialize body by body. Let the game client decide what to keep.
    v load
      v world.loadBody(body) accepts client ID
  v generalize schema util. "Jsonizer"
  v Spirits
    v each must declare a schema, to save/load anything beyond "id".
    v world.loadSpirit(spirit)
v Fix trigger-down bug. Why does it get stuck? Repro? Seems like mobile long-press --> right-click
v Fix balls going through walls on level start.
  v pad world brects. Maybe be a good iea regardless.
  v Ahah! Fix bug where distant wall bodies don't exist yet.
- World to/from JSON II
  v Add some robots with periodic timeouts.
    v Sound
      What's the simplest solution? Just a pile of sounds, with in-measure time...
      (And voice number? If the spirits allocate their own audio nodes, they don't get GCed. Optional.)
      [
        ['sound', in-measure time, voice?, vol, attack, sustain, decay, freq1, freq2, type],
        ['sound', in-measure time, voice?, vol, attack, sustain, decay, freq1, freq2, type],
        ...
      ]
      v Add measure timeout
        v remember timestamp
        v create all note timeouts
    v Movement
      v Accel on each sound, based on volume?
    v spashes
  v save/load Timeout events
  - save/load splashes
    - move data out of closures and into standard fields, with schema?

More triggers, with icons and keyboard tips.
- wall trigger
  - icon
  - key tip
  - spash
  - sound
- floor trigger
  - icon
  - key tip
  - spash
  - sound
- Last in wins
- grab trigger
  - icon
  - key tip
  - separate grab indicator
  - make it easy to intercept small moving objects, since terrain and object cursors are decoupled

- pause button
  - icon
  - move to top-right corner

Rotation
- Body
  - orientation
  - angular velocity
  - moment of inertia
- Pulling from off-center can change orientation
- Collisions w friction can change angVel? Hm...

More Objects
- Bumper
- cave speeder
- tractor-beam player
-

Delete
- Trigger
  - icon
  - tip
- instantly delete grabbed object if any
- otherwise go into grab-and-delete mode, which grabs and foreshadows deletion in, say, 500ms, gradually reducing timeout
  until it gets to 0ms? Releasing the trigger sets the timeout back to 500ms?
- splash
- sound

Add
* parts menu is just a bunch of triggers. Maybe add "repeat last add" button in more convenient place?
* Add at cursor. No need for "bubble".

Possession
- "enter" button

Make the cursor be just another Spirit, saved/loaded like everyone else.
* Empower Spirits to get at World and Game to make this happen.
- spirit can get world trackball and triggers
- prove it: Something else can get trackball/trigger

Orientation
- Bodies have orientation, moment of inertia, and angular velocity.
- create repeller turrets
- Cursor force can rotate bodies.

Game1 Splashes II
- muzzle flash
  - player fire
  - enemy fire
- bounce
  - need point of contact!
- bullet destruct
- boulder bounce?

Add & delete objects
- Add action, menu... oh no, menus!
- Deletion pseudomode

Non-pointerlocked mouse UI, perhaps direct-touch UI too?
* flip between non-scrolling direct-touch/mouse, and scrolling trachball cursor.
- touchscreen toggle on left
- keyboard key toggles it
- still draw cursor

Zoomable?
- two-touch pinch/unpinch
- mouse onscroll, like Vorp
- keys, maybe "[" and "]" or "," and "."
- Touching the zoom indicator buttons zooms to that level Maybe four: close, medium, wide, far.

Lifting?
- If cursor distance is too great for too long (low-pass average dist?), "lift" the object
- Lifted objects are treated as though they are uniform density, normal MOI, with no physics or collisions.
- Can lifted objects be sensed with rayscans? No, they're transferred to the "none" group.
- Only one object can be lifted at a time (worry about multi-user in the distant future).
- Lifting ends when you release the object.
* When time is frozen (upcoming feature), all object-movement is by lifting, because there is no time for physics.
* When adding objects, they are lifted as they leave the menu.
