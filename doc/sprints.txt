Drop & Throw
v add kick+move = throw (implement as insta-kick)
v keep kick+stillness = drop

Make enemy development easier with some library biz.
And make inanimate objects a lot cheaper too!
v Wake and Sleep: hooks around timeouts, distance limits, friction, nearly-drawn, low-power, bump-wake, other wake
  v document Ant spirit efficiency biz
  v make it re-usable for spirit
    v plan it!
    v pull it up
  v use in spirits
    v ants
    v all inanimates
      v performance savings confirmed
    v fix editor to auto-wake anything that's dragged
    v fix anybody missing passive timeout loop
    v make body wake spirit when vel changes to non-zero
      v like change listener, add optional link to wakable spirit!!
        v undo maybeWake hacks
          v body itself
          v player tractor
          v editor
    v centipede is the trickiest! If any part is active then all parts should be active.
      v just make it not broken, using active loop
        v play
        v edit
      v going to sleep
        v awake head checks whole body.
          v each body part must have canSleep(), including head.
        v If all may rest then head tells them to all become inactive.
      v waking up
        v any inactive part that gets drawn or close to it signals all other parts to wake.
        v they all become active immediately so no more signals happen until next sleep
      v joining
        v an active centipede joining an inactive one causes it to become active

v Fix Chrome audio on laptops. https://developers.google.com/web/updates/2017/09/autoplay-policy-changes#webaudio
  iOS touch hack, but for keyboard and mouse too?
  resume() if audio context is not running
  v game4
  v everywhere else!

Game 5 skeleton
v code nest
v remove unused spirits
v remove tractorbeam
  v from playerspirit
  v from controls
  v from splashes
  v from sounds

x Fix pointerlock everywhere.
  No I messed it up, and decided it wasn't worthwhile. It's good enough.

Player movement
x use mouse trackball
x limit max accel, like game2
x stun when hitting things hard, to prevent super-strong pushing. Lowers max accel more.
v floaty garbage because I love it!!

v base weapon responsibilities
  v setWielder(spiritId) to read team? Or just setTeam? Changing spirits releases trigger I guess
  v trigger API: down, up. Call down and then up immediately for one-time shot.
  v enforce rate-of-fire. Remember last fire time.
  v read owner body's pos, vel, angpos, angvel when firing
  v manage sounds, graphics, and actual fire effect such as creating projectiles
  x maybe draw, also based on owner body
  x setRateMultiplier(something around 1) nextFireTime = lastFireTime + fireDelay / rateMultiplier
  x expose properties like shotSpeed, shotSpread, shotRange, inaccuracy, splashRadius, for general aiming/firing alg.

v laser
  v player
  v ants

v fix rayscan-debugging graphics

Scanner: Vision and target-finding
* Scans for unobstructed targets
* Can lock on to targets to track them more aggressively
* Knows last time target was seen, pos, and velocity.
* This is all great but it is separate from movement
v always do random scan, track random scan separately from locked scan
v client decides what to lock to. Add setLockedSpiritId(id) and breakLock()
v if now - lastLockedTargetSeenTime > maxBrokenLockDuration then break lock
v if lock unbroken
  v if lock target overlaps lock-view cone
    v scan to see if view is unobstructed
      v center scan. if hit, done

v ant integration
  v ant fires when it sees target
  v ant locks target
  v ant turns towards locked target
  v ant follows target around corners
    v move to target last pos
    x rotate to target last velocity
    v start search fresh
  v ant loses interest if it cannot find target after a while
  x ant loses interest if it sees target destroyed

v searching
  * more efficient rayscanning when you're looking for rare bodies
  v Do clear scan for targets (only check for targets, not obstructions)
    v If there's a hit, do obstruction scan
v less randomness, more regular sweeping

- ClearPathScanner: class for finding a clear path
  - short scan for obstructions in desired motion direction
  - sweep-scan out to sides to find nearest unobstructed angle
  - state updates to include
    - unobstructed direction
    - isObstructed, and then
      - obstruction distance
      - obstruction path ID (to get body ID or spirit ID etc)
  - params:
    * scan rad = body rad
    * there is no scan period. This scanner is on-demand.
    - scan group
    - number of scans to the side to do (chages with stress so we do need it)
    - angle increments of the side scans
    - scan length
  - integrate into ant

- hearing sense
  - SoundHistory class
    - backed by circular buffer
    - records are SoundEntry objs, pre-allocated to fill buffer
      - type
      - location
      - time
      - radius (simulates effect of volume)
    - lastSoundId starts at -1 and goes up by one each time
  - Hearing module for spirits
    - Spirits remember their own lastSoundId
    - when active but busy (target locked) they just set this.lastSoundId = soundHistory.lastSoundId
    - when just becoming active, also ignore prev sounds
    - when bored, process unprocessed ones in order
      - scoring: priority(type) - (age + distance / speed)
    - copy the fields for their last highest
    - each "bored" enemy
      - looks at ALL of them
        - decides on most attractive
        - copies the record to a local cache
      - tends towards sound until its score is 0 or until it is forgotton
  - if a target is seen, that clears the hearing record

- better combat
  - melee weapons scan and lash out at target in range
  - non-fatal hit:
    - stun
    - N-frame white flash (need to handle render-time biz like that, not in world-time)
    - force applies to attacker and defender, but mostly defender
  - fatal hit
    - changes spirit to corpse, with lots of knockback
    - corpse turns to dust easily

- Encapsulate behavior: WallAvoidance
  - uses ClearPathScanner
  - moving in a given direction
    - angular friction
    - linear friction
    - turn towards direction
    - and thrust (proportional to direction alignment + constant)
  - stress?
    - influencers
      - obstructions increase stress
      - clear path or target-visible clears stress
    - effects
      - 100% stress means lots of obstruction, maybe trapped. Subtle state change:
        - clear-path side-sweep scan count = 0
        - should also stop scanner I guess
        - randomly freak out instead since plans didn't work.
      - if unstressed, wanderers turn randomly
      - stress decreases thrust, to avoid ramming into walls


V .............. V
V                V
|   WELCOME TO   |
| THE LATER ZONE |
|                |
V .............. V

- weapons show up on carriers? Need special weapon graphics.
  * iconic grx for every weapon
  * show it outside of creature, in fire direction
  * show it inside weapon-pickup bubble

- weapons
  v slow shooter
  v medium shooter - machine-gunny
  v laser 1.0 - long, straight, no bounce, frequent
  - telegraph laser fire with sparks, add delay
  - shotgun - short wide, a bit bouncy, infrequent
  - magic missile - seeking, avoids walls. Infrequent!
  - rogue gun - medium, narrowish, very bouncy, low damage
  - rocket - dumb, infrequent, explosive
  - saw - really short, constant, cuts through walls.

- level generation

- health framework
  - damage is floating point
  - health regenerates from fraction to whole number
  - healing jumps you up by exactly 1
This solves some problems:
1) Not all weapons have to be all-or-nothing damage, (though maybe that would still be a good forced simplification)
2) There can still be specific health-based modes
3) Folks aren't walking around within a hair's-breadth of dying.
4) Player is encouraged to concentrate attacks on an enemy long enough to drop it at least one full HP.
5) health can still be displayed with integer chunks

Fun props:
- bumper
- blipper
- portal
- repulsor cannon

- target-intercept behavior, like tractor beam
  - search for target
    - random search (or structured sweep?)
    - compare candidate target with current target if any.
  - target chosen
    - scan to target
    - move to intercept
      - choose along vector of where target is (0) and where intercept point is (1)
        - pull out intercept code for Avoidance
      - adjust vel to target vel or whatever
- target-avoidance
  - same as intercept, but adjust vel away from target vel?
- Also do diff between "hit target hard" and "come to rest at dist D from target", mjolnir-style

Impl concepts:
- desired distance
  - negative infinity: ram target hard
  - small negative number: gently push target
  - 0: rest just barely touching target
  - small positive num: follow target w/o touching
  - positive infinity: get away from the target!
- lead/follow
  - try to get to where target will be in f(positions and vels) time
    - zero:  dumbly go to where target is now.
    - positive but proportional to... dist?: lead the target
    - if negative, try to get to where target would have come from - go behind target

