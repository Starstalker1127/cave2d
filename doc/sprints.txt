cave2d.com/<game path>/edit is the main editing UI, with adventures, levels, level editor, etc.
* Like Vorp, this is a single-page app with a hash-fragment query string.
  That means that the level editor's unzoomable meta tags need to be added/removed dynamically.
v Page baseclass
  v enterDoc
  v exitDoc
v AdventureListPage: If no adventure is found, clear the query and show the adventure list.
  v look in storage for paths like [<game>, "adventures", <adventure name>, ...]
  v show 'em in a list
  v "create" button for the whole list
  v for each row,
    v copy
    v rename
    v delete
    v hyperlink to enter adventure's levelList. URL: game2/edit/#adventure=<name>
v App class
  v hash fragment query parser
  v listen to hash fragment URL changes
  v ref to page now showing, to call exitDoc on it, then enter the new one.
v LevelListPage: If adventure is found but no level, show that adventure's level list.
  v link back to adventure list
v LevelEditorPage: If adventure and level are found, show that level's editor.
  * analagous to test38/main.js's starting point
  v update HTML
    v write canvas
    v write pause menu div
    v make Pages update body CSS
    v update and restore head meta viewport content
  v update pause menu
    v name of game, hyperlinked
    v name of adventure, hyperlinked
    v name of level
  v preload shader text files
    v make main.js pre-load shaders in a TextLoader
    v LEP either uses the shaders immediately or waits for a single callback.
    v copy RendererLoader code into LEP to create WebGL context.
  v create WebGL editor "screen"
  v save & load v1
    v load in enterDocument? Or when shaders are ready?
      v inject starting JSON into PlayScreen
      v if no JSON file, creation starts with mostly-empty default world
    v save on exitDocument
    v save on onBeforeUnload?
    x save occasionally
    v no sharable URL form now because that messes up the URL scheme. Add Import and Export later.
  v In mobile level editor, stop single-tap-button events from teleporting cursor!
  x exitDocument
    v stop listening
    x tear down WebGL, if it is set up, if nuking canvas doesn't do it already.

Export
I still like the idea of sharing a level by URL, but I also like sharing an adventure by JSON
/<game path>/export#, #adventure=xxx, and #adventure=xxx&level=YYY exports the relevant data to text which can be
copy/pasted into /game2/ file.
/<game path> is for playing the exported game.
v ExportPage
v Export link on each adventure.


Sprite configs...
A single spirit class, plus body, may have variations that result in multiple... what? Characters? Parts? Items?
* To distinguish them in the menu they should have different "icon" models, even if it's just color or size or minor
  variation.
* Serializing includes typeNum. Keep it in the spirit API.
* When deserializing, there should be a straight lookup from spiritType to (uniform) Spirit ctor. But it's many-to-one!
* Instances draw and make noise with Spirit code
...
* I guess a Spirit should be able to create a Model, using params.
* And a Spirit should be able to create a Stamp too, using params.
  * But cache 'em w PlayScreen "StampCache".
  * Cache key is all params that went into creating 'em.
* Menu configuration means...
   * creating Spirits with params and getting icon Models from 'em. OK.
   * having factory code for each menu item, to generate default values for spirit, body, etc
     to insert into world at x, y, d

SpiritConfig - one per spirit-type per game, concentrating the scattered Spirit stuff,
to help make coding a new spirit easier.
v Create a config that ties together the misc. sprite junk
  v type number (for serialization and deserialization) and also primary key for this game
  v stamp (just one? That'll change.) for rendering.
  v optional menu stuff. Maybe a list of these?
    v item name (why different from type number? Use type number?)
    v group
    v rank
    v model, for generating menu stamp
    v addFromMenuFactory
      v sets up default body
      v calls spirit constructor
      v overrides constructor biz maybe.
      v uses stamp
  v whatevs is needed for playscreen's fromJson()
    v deserializationFactory?
      v deserializes body
      v calls spirit constructor
      deserializes spirit state
      v uses stamp
  v menu creation
v Create one big map from spiritType to SpiritConfig
v Read from the SpiritConfigMap in all the right places in PlayScreen
v convert existing spirits
  v AntSpirit
  v PlayerSpirit

Modes - Edit, Test, Play
v rename PlayScreen to EditScreen
v change EditScreen "pause" button to "settings" or something
- Make TestScreen too
  v code nest
  v Button to get to it from Edit screen
  v css
  v camera follows average player-spirit position.
  v left-arrow button in TestScreen to navigate back to edit
- in edit mode,
  - spirits don't move or create on their own.
  - collision interactions are limited to bouncing. No collecting, exposions, unlocking, exiting, etc.
  - Friction is applied uniformly by the editor?
  - Spirits may render differently, to help the editor position and orient them.
  - Leave the door open for spirits that help you make a level - diggers, sculptors, etc.
- in test & play mode
  - player controls work
  - self-driving ant

super basic Player
v PlayerSpirit shell
v timeout cycle
  v friction
  - controls
    v trackball on the world
    - button on the HUD? Uh oh need modes first so button doesn't block editor controls.
v remove ant behavior from player
- draw a little face on it

Exit
  - square with the word "exit" written on or above it.
  - in play mode it triggers transition and then next level, or victory.

Screen refactor
- Pull common Test/Edit/Play stuff up to BaseScreen.

Level Play Progression
- make and export a few levels
- play uses big exported FileTree JSON file, read via XHR.
- game2/ adventure list, from FileTree.
- click on adventure to play levels in alpha order
  - game2/#adv=foo&level=bar plays that level? Or keep it all in memory, no bookmarking?
- in-game pause menu - resume, fullscreen, quit
- victory page?

SplashConfig
* similar to SpiritConfig, except that there's no menu item for splashes

Orientation
- Bodies have orientation, moment of inertia, and angular velocity.
- create repeller turrets
- Cursor force can rotate bodies? Or cursor motion changes body orientation anyhow.
- editor

Enemies
- gnome
- gnome generator

Collisions and Controls
- Feed player collision force into trackball, to stop wall-pounding?

TestScreen time controls
* centered on top. These are totally unneeded but probaby would be awesome.
- pause
- play 1/4 speed
- play regular speed
- play 4x speed? or faster?
- super speed

Custom dialogs:
- prompt
- confirm

Attribute editing?
- Spirits can expose a type+key: value form
- Mode button opens form editor

Test XX: Undo and Redo
- retain last N JSON serializations in RAM or wherevs.
- Create new ones using one-token-bucket throttle right before mutations, w 1/sec(realtime) restore rate.
- Always save the just-after mutation camera and cursor pos, to bring the area into focus before undoing.
  Keep that as a separate kind of undo record, since it's so tiny and easy to restore.
- Button for creating an undo record just because time went by. Snapshot?

Zoomable?
- two-touch pinch/unpinch
- mouse onscroll, like Vorp
- keys, maybe "[" and "]" or "," and "."
- Touching the zoom indicator buttons zooms to that level Maybe four: close, medium, wide, far.

Lifting?
- If cursor distance is too great for too long (low-pass average dist?), "lift" the object
- Lifted objects are treated as though they are uniform density, normal MOI, with no physics or collisions.
- Can lifted objects be sensed with rayscans? No, they're transferred to the "none" group.
- Only one object can be lifted at a time (worry about multi-user in the distant future).
- Lifting ends when you release the object.
* When time is frozen (upcoming feature), all object-movement is by lifting, because there is no time for physics.
* When adding objects, they are lifted as they leave the menu.
