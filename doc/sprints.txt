2014-03-22
Resizing Canvas - just for one page.
v window measurement
v resize event listener
v canvas resizer
v put it in cave2d site

2014-04-28
Viewport and camera
v viewport has resize callback
v camera has pan, rot, and zoom
v works w test page


2014-05-08
Some nodes...
line node {
  series:[{t, pa, pb}, {t, pa, pb}...] sorted by t.
  startTime: t, or default to series[0].t
  endTime: t or infinity or series
}
translate node {
  series:[{t, pos}+] sorted by t.
  startTime: t, or default to series[0].t
  endTime: t or infinity
}
rotate node {
  series:[{t, rads}+] sorted by t.
  startTime: t, or default to series[0].t
  endTime: t or infinity
}
scale node {
  series:[{t, scale}+] sorted by t.
  startTime: t, or default to series[0].t
  endTime: t or infinity
}
// zomg the power of the series! Slomo, fastmo, reverse, scratch...!
delay node {
  series:[{t, delay}+] sorted by t
  startTime: t, or default to series[0].t
  endTime: t or infinity
}

2014-07
Basic Nodes
v line
  v one whirly hexagon
v translate
  v two moving whirly hexagons
    v tree traversal is automatic
    v basenode works as collection of subnodes
    v subgraph reuse works
v rotate
  v wiggly arms demo
v scale
  v other wiggly arms demo
v delay
  v shifty clock demo

DONE Milestone: Animated canvas thingy with variable speed time
========================================================================

2014-07-13
QuadTree and demo
v basic quad
v color with a shape (circle?)
v demo

Quadtree Grid
v edit like a quadtree
v serialize & deserialize
  v port bit manipluation
    v bitqueue
      v test
    v base64
  v quadtree s27n
    v ser
    v des
    v test
  v quadtreegrid s27n
    v ser
    v des
    v test


Editor Improvements
v Only redraw a dirty rect, or a list of affected quadrants.
v Mouse support
v Hall Pills: Affect the space between to events connected by dragging - update HallPainter,
and capture drags in event handling code.
  v dist from segment to point
  v drag tracking
  v proper hall pill painter

v Simple AABB rect object, like vec2d.

#### MILESTONE: Nice editable mazes, for mouse and touch
#### COMPLETE
What I learned:
* Quadtrees are cute but kind of a pain in the A too because they're not a simple grid.
* The system of void/wall/floor drawing is good. Keep it.
* Multi-gesture+mouse drawing-based map editing is really great, and I want to keep that.
* Turns out the Vorp code isn't as easy to reuse and adapt as I'd hoped.

Now it's time to rewrite the physics & gameplay engine, to be easier to understand and use.

Body
* Used by the internal collider to enqueue future events.
* Used by the internal default collision response code.
* Used by Sprites, through a careful API which handles pathId invalidation.
v Identity
  v id
  v spiritId or 0
v Path
  v pathId - changes whenever a trajectory field changes. 0 means it's invalid.
  v pathStartTime - just for calculating position as func of time
  v pathStartPos
  v vel
  v pathEndTime - for not looking ahead too far, if acceleration is scheduled.
v Shape (affects path)
  v shapeType (circle or rect)
  v rad (for circles)
  v radX (for rects)
  v radY (for rects)
v hitGroup (changing invalidates path. Probably changes infrequently.)
v mass
v elasticity
v getPosAtTime(t, out)
v getBoundingRect(t, out)
v set pos & vel
v alloc & free
I'm trying to be uncompromising: Don't create an object field pointing to a parent. Pass the parent in to methods.

Spirit baseclass
A spirit subclass can have lots of custom logic, scheduling, sensing, body-manipulation, etc.
v id
v world event handlers: start, timeout, hit
x bodyIds? Or just methods that take lists of bodies, and single bodies?

World (but not all its collider aspects)
v spirits {id: spirit}
v bodies {id: body}
v pathIdToBody {id: body}
v world's spirit-facing API:
  v addBody
  v removeBody
  v getBody
  x setTimeout
  x cancelTimeout
  (later: rayscans)
v getBodyByPathId purges obsolete pathId keys

How will path invalidations get buffered up for when the World needs to move time forward?
Easy way is to make each Body hold World, like a parent pointer. I tried to avoid it but maybe I can't.
It's cleaner to include the PathInvalidator in each Body, and the World, like Vorp does. Sigh, OK.

Start Test 8 - A World
v Simple renderer
  v draw bodies
  v viewport surrounds everything automatically
    v do it body-by-body for now, until cells exist

Event Queue, and Time.
The world has a big queue of events, in time order. Future events are predictions that may be invalidated by earlier
events.
The trick here is to separate the runtime order in which events are added, and the game-time order in which they
are dequeued and processed.
v init events: body entering cells
v init events: body exiting cells

DONE 2014-10-05
v add-to-cells
  v initial addBody add-to-cells
  v add-to-cell
    v add to group layer
    v add collision events
      v actual time-to-collision checking
        v brects
        v rect to rect (same as brects?)
        v circ to circ
        v circ to rect
        x unit test?
        x fix double-hit across cells? or no? Only happens on initial add, right?

Process the queue
v Process enter events
  v add to cells
  v create next entry event
v Process exit events
  v add next one
v Process collisions
  v default collision response
    v calc accel
      v circle/circle
      v circle/rect
      v rect/rect
    v alter paths
  v spirit callbacks
v Process collision v2
  v World only detects
  v Game uses resolver, or whatever, to handle hit events.

Timeouts:
v timeout event: spirit scheduled to do something, like accelerate, sense, react to something that happened earlier, etc.
  Scheduling things to happen at floating-point times is the key to making reflex-time important for NPCs

Cell collider
v sparse grid of cells
v cell
  v array mapping hitgroup index to list of pathIds
v map from bodyId to body
v map from pathId to body. (If a body has a different pathId, then the index one is invalid)
v body creation causes...
  v overlap tests & immediate hit events w bodies in cells
  v time-to-hit tests, events (multiple)
  v enter-cells test, event (zero or one) - bounding rect's leading point crosses a cell x or y line
  v exit-cells test, event (zero or one) - bounding rect's trailing point crosses a cell x or y line
v enter-cell event causes
  x overlap tests (maybe not?)
  v time-to-hit tests
  v enter-cells test for next edge or axis
v exit-cell test removes bodyId from departed cells

v Test 9: Bodies animated by a spirit, using timeouts

#### MILESTONE: fully functional physics for aarects and circles
#### STATUS: DONE 2014-10-12

DONE 2014-10-19
Rayscan
API?
world.rayscan(hitGroup, startPos, endOffset, shape, rad, rectRad)
returns a WorldEvent? No. Separate RayScanResult thingy, allocated by client.
v world.rayscan(request, result);
v RayscanRequest has that stuff: hitGroup, startPos, endOffset, shape, and one of rad, or rectRad.
v RayscanResult: is like a WorldEvent a little


Controls
The idea is abstract away the following from the game logic:
1) Device type: keyboard, mouse, trackpad, touchscreen, or combo.
2) Sample rates and game framerates. Use milliseconds for everything.
The actual JS events happen between frames.
They could be buffered by the event-handler code, and then consumed on-demand during the event loop.
But they should also ping a callback, because it's possible to do really on-demand between-frame
physics updates, by advancing the simulation up to the time of the event, and then applying the effect.
When the animation-frame hits, it advances the sim the rest of the way, then draws, I guess. Hm.
I'm assuming that I have 16ms to simulate and draw, after each 60Hz RAF event, before we start skipping frames.

Example: A player taps the "x" key: down/up between frames. It should still count, so final state isn't enough.
But if a player is holding a button down, that needs to persist too.
So the controller is stateful, consumes events, and produces state and more events.

Basic use cases:
1) Button: queue every down and up, with timestamp, plus current state and start timestamp (last event basically).
2) Stick: current vector, w magnitude from 0 to 1. Plus down/up state w timestamp, queue, last.
  * kbd params: the keys for up/dn/rt/lt
  * touch params: drag radius, boundary function
  * pointer-lock params: can it be done? Does it still give down/up?
API considerations
Write games for multiple input types, joining multiple input classes into one abstract input.

Example 1: twinstick shooter supporting keyboard, touch, and mouselock/keyboard combo.
* Define movement keys and touch-zone, and combine them into one Stick for movement.
* Define firing keys, touch-zone, and mouselock, and combine then onto one Stick for firing.
So all sticks types, like KeyStick, TouchStick, and MouseLockStick, will have different configuration options
(keys, touch-zones, radius, etc) but they'll all produce the same output. Then a PolyStick can accept many
sticks as imput, combine them, and produce the same kind of stick output. One could also create a BackwardsStick,
a SpinningStick, a RandomStick, DelayStick, other handicaps, both as filters and as additions.
How are sticks combined? Add inputs, and clip (not scale) to unit circle.

Example 2: Vorp's grab and drop buttons.
* Keyboard: Z and X
* Touch: define two overlapping rects or circles or whatevs - functions of touch points I guess?
* Mouselock: map left and right mouse buttons. (new idea there!)
How are buttons combined? On every child up/down, the parent is down if any child is down.

2014-11
Sticks
v Stick base class
v KeyStick
v TouchStick
v MultiStick - adds input sticks and clips the result
  v demo KeyStick and TouchStick on the same page
  v demo twin-stick shooter - multiple sticks of each type
v PointerLockStick

v Leaked cells when removing body?
  v test
  v fix

2014-11
Canvas layers
Examples:
* Background with map, drawn once, redrawn only in dirtyrect chunks when map changes.
  May be written to with marks and stains and stuff as the action wears on.
  What's special is that the canvas holds the entire background, and the canvas element itself moves.
  Is that even wise? Maybe I should use a tile system, where the tiles are canvases that get rendered and recycled
  as needed. But lets just get a single giant tile in there for now.
* Foreground with all the action, fully redrawn every turn. The canvas itself does not move.
* Debug overlay layer that can be turned on and off. Also probably shouldn't move, but maaaybe.
Tasks:
v Make it work
x Make a reasonable API

2014-11 to 2014-12
WebGL renderer
v Static level background
  v JS to load GL mem (see test15) using world coords
  v JS to set uniforms to translate world-to-view. Model-to-world is identity, since model == world for background.
v Dynamic foreground objects, at all
  v JS to load model data into GL mem using model coords.
  v JS to set uniforms for model-to-world, world-to-view, plus color or other uniforms
v circles


2014-12-26 to...
FRACAS II
Remember my first JS game ever, http://plexode.com/fracas ?
Time for that remake, featuring the same ascii text level format, roughly:
.: floor
#: wall
%: (new!) destructible wall
g: gnome
G: gnome generator
$: gold
+: health
@: player start
>: exit

Gnomes will wander, avoiding obstacles, until they see the player. Then they attack!
Generators do a rayscan before generating, to avoid overlapping.
Treasure and health won't occupy the whole floorspace. Monsters can go over them...
But to make up for it I'll add destructable walls the player can blast through.

Engine features I still need:
* SparkEngine
* Sound

v simple async dependency loading solution
v load maps
v init world from maps
v init GL program with shaders
v init bg buffers
v rayscans for gnomes
v group-based collision detection
v combat rules
  v gnome death
  v player damage and death - reload next level for now.
  x player health indicator - hearts at the top of the screen? Or facial expression? (Face. Design, impl. below)
v exit to next level
  v Exit spirit
  v basic rendering
  v bullets don't bounce off of it
v generators
  v spirit and renderer
  v gnome creation
  v destructible
  v rayscan
- new colors
  - exits
  - generators
- treasure? Or destructible walls?
  - spirit
  - renderer
  - collision rules
- health
  - spirit
  - renderer
  - player health indicator, no matter how lame. Try MIDI-maze smiley-face. Or color, or both.
  - player's health carries over from level to level
- states
  - you lose
  - you win
  - main menu
- explosions & sparks
  - gnome destroyed
  - generator destroyed
  - player damage
  - player destroyed
  - wall bump
  - wall destroyed
- sound effects
- graphics models
  - player
    - mouth
    - eyes
    - arms and legs?
  - gnomes
    - eyes
    - mouth
    - arms & legs?
    - hat! Maybe like http://plexode.com/eval3/#s=aekVQXANJVQMbAx10AYMeFBERAYIeF5sBSkUePQNEQk+mHx0QdB89TwMNA0uRk3APdqUDSE9QTkZUphyxsWABcQkKAVyxREQPR0pNTTRVWk1GvARHRUXEz9FDRkhKTzFCVUnLxU/QD05QV0Y1UAkOEg0B+QrueBNc71e76fgSfziB8BJ8DBMFCIPDUId7RhcNfL7iESf7RIhNKBUIzpdbthLTasligPKhVKZQJhGlJeYxPZDkIRTIrLZsmajWbDabjfcADjgPcjmdDqdkTeDyej2fASB8PiNNisCqL5qkZq8KrL3CL7B0Qg9Gi1RqcPr1oglcAMatlgBNiANqr0ekEipcpeEnJt9aMsl0wmU0ZBGLTCnbOlV/a7ZbamAibCLhlVIc8jplGnBEfEQC1j0MZB4RDMZ0emCNmhN5kObwLSn2ywcvmNezNKklez10B+ifmkuGm1Fw1Sb1sq1973lGv+1lu3wyqmoBX8hxkJ3Wxr2PoGSAbdb+XeG+utkB4T4MQCYYjPpCr7NIxFQMiAV720r22wsTTN1TIPIVm8TxmDlZpfFeU9F34aUFFyQxUYOcSEFGf1uDugAxwBEk6naY5PmQUFkxHJt5Tjghu2cQmDFaWpwXpBmEUNegEwPBiNFpVSMUQjNRnMd1z37hd0n+hphwBTgTogPB3IKUaLlhV1RhSFYQhFFM6hKEQJBWFNUFhcBpVVBdpQXfyRoZduKpCQl5wPmZxHGe1Y30Co+3KPCGHUhySxUAkVTMY2exCPRskWDgozrAEHnEBIFlGS0qRUE06kxVWejRS4VaXAkaRUOegQLRCaABBAAQTPxxH5O6S2yFMwhVFCsW1oaa0qomixJo2j6RQkVCoNpUp5V6kxPpWnqZV6nKeqCohVqScQWMyqKqA6rETq+zKyrRuCxht1jaEiTYpUmbkqlJdJUQmVpYloVZcl6YI1eppXyo9pY/QlbW/exVpFYSuLhMi46AoKBqFoeNKKEU66OWWv0qFSt2yseyRVTFw1xUazcZp+oRPoG1apRO46wt2tX8xV/LCTFGF2saWrIpbH8bwBCceTGz8itFUwRBMCgQ0E7sntxLLeyjSMqkh1Sor0SBGEMSgJKYqCqANV69KgD9RFUJBQE/GRZFUCQIBMRQIROHC+MBMRZPsWj7Ek+xXPvCGNAEAUAQLDaMxBVDu3qe5qiMRq9ZNlWX4Ngss4LezRxfNdv3FE+MA/OsgtC0ozAuj+W5BK8uAkFl16XoDK6Cf8j4/BusLHek3TlKd6diuN6Yli+ggNzuwh2H+gPCsdLwNNBhFWvQJGIZAKGWp12Js7ttMECSaXWkF19ndwQq0sfTpjpZ5Bn2nHAGgvSL/1CgJy2PY+L5F1FXQ0TAgCCzAMThUJIAwSBH9woDrf2BJ/4VQlwCAGF4AAA=
    - hat could fly off during explosion...
  - bullets --> arrows
    - big signage arrow pointed in direction of flight, like Dandy
    - arrows stop and blink out when they hit a wall (file under explosion)
- control tweaks
  - single fire button, laser scope?

Bugs
- Simultaneous-corner-bounce interpenetration.
  - Repro unit test
  - Fix

2014-12-22 to...
Sparks
Splashes and explosions can use a circle, with a time uniform and a dist-from-center varying,
and kind of a fancy frag shader.
Vertex shaders could be lots of fun, for glitching, warping, prismo-style beam-in for isometrics,
robotron-style stretch-splosions.
v Nice simple explosion shader with time param.
- JS for throw-away graphics effects.
  - Separate SparkEngine class for one-shot graphics (and later audio)
  - Recycles records used to render to GL based on time param.
  - Garbage collects expired rows.
- Make hitting a wall splash a little wall color.
- Make bullet hits explode enemies (which makes them re-appear far away from the player)
- Make firing a bullet spash a little bullet color.

Web Audio
Create an SoundMaster object that has the context, handles the listener position,
and provides one or more actual audio nodes to connect game sounds to.
(For instance: Events in the world, ambient noises, music, announcements, etc.)
Spirits can create one-shot noises by passing SoundMaster to static mode creators.
Spirits manage continuous sounds by creating a long-lived object, passing in SoundMaster,
and then tweaking knobs the class exposes.
- SoundMaster lass
- one shot noises
  - collisions with various substances
     - wall
     - creature
     - bullet
- continuous sounds
  - player motion
  - critter motion
  - rayscan spirit

Proper Outputter
* Combine sound and graphics for splashes and stuff.
* Sound and graphics engines are reusable and generic, I hope, but outputter is game-specific.
* Basic graphics engine can draw primitive shapes in solid colors, and lines?

Complete Game
- Main Menu
  - Graphics!
  - Sounds!
  - Instructional Instructions!
  - Settings!
- Starting a Level
  - Getting Killed
  - winning the level



Buttons
- base class
- KeyButton
- TouchButton
- MouseButton
- MultiButton

Slider
basically a stick where I project the value onto a line, and a renderer

Checkbox
a button with bit attached, and a renderer

Editor Skeleton
- nav/wall/air mode switch
v pointer-based grid editing
  v circles at each event
  v touch
  v continuity between event points on drag
  v mouse
- drag-based panning

Make a maze and play it.
Terrain URL
v port stuff
  v url
  v lempelziv
    v map
  v squisher
- button saves sharing URL to textarea
- button dismisses textarea
- onload parse URL

Game UI Nav
- list of levels
- start player with data D
- start editor with data D


overlap
- rect/rect
- circ/circ
- rect/circ
- init events: body overlap
- draw overlaps and non-overlaps

