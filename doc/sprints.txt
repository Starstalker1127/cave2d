2017-06-18

game4 nest
v take over old game4

reduce setScreenListening redundancy
v shrink testscreen's setScreenListening()
v ditto for playscreen
v repeat for all the play/test code that could use it throughout cave2d

2017-06-24

v testScreen inherits from playScreen, to de-dupe a lot of code.

game4 multiplayer controls
v controlName, controlState files
v create the 7 slots
  v study test45
  v page calls configurePlayerSlots() near initializing the world
  v screen.configurePlayerSlots()
    v models and stamps
      v models.glyphs
  v screen.handleInput()
    v slots
      v join
        v playerJoin(slot)
          v playerSpawn(slot)
      v drop
        v playerDrop()
    v PlayerSpirit.handleInput
      v unpack and use controls
      v make tractor beams work like test45
v Render the hud
v Add the mid-screen pause widget

2017-06-28

game4 multiplayer rendering
v zoom
v selective tile draw
v selective spirit draw
v shader for circle mask

Refactoring
v pull renderer up out of test44-45 and game4 and replace the main renderer
v standardize metrics, graphing code chunks
  v initStatMons
  v fields
    v statMons
      v leftStatMons
      v rightStatMons
      v drawLeftGraphs
      v drawRightGraphs
    v cuboids
      * add to CuboidRules
      v bottomRight
      v topRight
      v bottomLeft
      v topLeft
      v graphsCuboid
  v sampleStats - overridden from WorldScreen, called from page.animateFrame()
  v drawStats

v pull game4's splashes into a new file, like I did for "sounds" (done except for unused explosion biz)

v delete game4.getAveragePlayerPos and everything that uses it

v player death
  v explosion
    v at all
    v move to Splashes
  v respawn timeout start
  v respawn

v fix crash when beam target body vanishes

Game4 Basic Mechanics
v entrance 1
  v entrance spirit
    v config
    v editor-able
    v remove player from editor menu
  v zero players
    v camera at entrance
  v add player at entrance
  v respawn after death
    v death by critter
v exit 1: basic game2 biz
v useful objects & activation
  * based on "Vehicles" basic neuron model
  * Each target has one input port that accepts any number of simultaneous connections.
  * Input values are steady values that change discontinuously, in sudden steps.
  v data structures
    v Source maintains map from target spirit IDs to output values to those targets, in case source gets polled.
    v Target maintains set of source spirit IDs, for polling.
    v Target also maintains map from pulse input end time to pulse input value.
  v activation by linked spirit
    v api
      v targetSpirit.addInputSource(sourceSpiritId) // set output value first in case target reads it
      v targetSpirit.removeInputSource(sourceSpiritId)
      v targetSpirit.onInputChanged(sourceSpiritId, val)
      v sourceSpirit.getOutputToTarget(targetId)
      x world.isOutputInputPair(sourceId, targetId) // debugging only?
  v activation by pulse or ray
    v targetSpirit.addInputPulse(duration)
  v target polls inputs on events and timeouts (anything that could change values)
    v targetSpirit.sumOfInputs()
    v iterate through pulses, culling obsolete ones and adding valued from active ones
    v iterate through sources, culling or adding
  v exercise the system
    v player activates indicator light
      v indicator light spirit that just shows whether there's any input or not
        v basic spirit
        v add to editor menu
        v polls for activation during rendering
      v player tractor beam can activate target
        v wield adds source
        v unwield detaches it
        v activate sets val to 1
        v deactivate 0
      v whole thing works
    v player wielding/activating/ejecting twists things to point along wield vector
    v activator raygun that serves 2 purposes:
      v it is activation target, like the light
      v When activated, it fires activation bullets that can activate stuff like lights and other rayguns
        v activation bullet spirit
          v collision triggers activation pulse

Movement again...
v traction or responsive movement
v good slow aim precision

Bugs and cleaning
v Unlock mouse pointer when paused, relock on resume
v Activator gun fire schedule
  v use new timeout (don't re-use friction)
  v don't stop firing when off-screen
v higher friction/traction on all manipulable objects

x change Wield physics? (what did I have in mind??)

v entrance 2: done 2017-09-17
  * continuation of player slots - don't make players re-add themselves
  * "gameState"
  v app/PlayApp
    v exitLevel param
    v VictoryPage ctor param (not that it matters)
    v createPlayLevelPage param
    v playLevelPageCtor call param
    v restartLevel param
      v createPlayLevelPage param
  v app/ScreenPage
    v ctor param
    v field
  v game4/PlayLevelPage
    v ctor param
    v pass fresh value to this.app.exitLevel
      * have a way to create a fresh one!
      v game4PlayScreen.createGameState()
    v pass old value to this.app.restartLevel
    v use in maybeCreateScreen()
      x pass to Game4PlayScreen ctor I guess!
      v page explicitly restores state with Game4PlayScreen call
  v game4/Game4PlayScreen
    v createGameState() called from PlayLevelPage
      v list of players
        v slot names or whatever
        x color?
        x position relative to exit?
        x velocity relative to exit?
        x equipment (later!)
    v Populate slotNames when creating slots.
    v method for adding a player by slotName
  v Slots
    * need permanent serializable IDs
    v replace random slot.id with real names
  v Maintain pointerlock across levels

v Increase "slot" responsibility
  v player spirit in slot
  v remove list of player spirits from playScreen
    v use slots instead
  v remove slot from playerSpirit
    v pass controlList to playerSpirit.handleInput
    v remove slot state checking from player
  v player circle (from spirit)
    v slot calls follow each frame
  v player camera (from spirit)
  v remove lastSpiritId
  v death
    v when player spirit dies, find its slot (scan?) to update state
    v know player death time
    v remember death position
    v nuke player spirit immediately because slot knows all
  v know respawn world position
  v respawn
    v do it on first frame after death time is up. No timeout.
    v and only if player is still playing
    v free: prevents player from dropping and respawning super fast

v death 2
  v fragment-view circle shrinks to nothing in-place
    * don't encourage dying to get extra info
    * slow enough to see how you died, fast enough to not be totally annoying.
  v ghost returns to spawn point
    x player gets ghost body? Maybe totally invisible non-body would be fine.
    x ghost pan/zoom camera circle doesn't affect shader during normal draw.
    x ghosts are drawn always - separate pass with different shader params so they don't get clipped out
    x touching spawn point restores solid player body, back to normal.

v exit 2
  * all players must be present and relaxed to exit
  v exit has circle body
    v new test level
  v 1/distfrac shader
    v add shader fork
      v borrow from test32
    v make existing weird shader near exit work first
    v draw exit as every player but using the weird shader
    v then try 1/distfrac shader
    v make players visible in exit mirror even when very far away
  x cache exit warp arrays
  x allow multiple exits to draw mirror
  ... OK, the 1/dist shader is cool but the idea for the exit was a bust.
  v start exit when all players are close
    v exit tracks player distances
  v arrow & star
    v models
      b arrow - tip is 0,0
      v star - center is 0,0
    v for each player
      v if too far, draw arrow between player and exit
        v scale and position based on dist:
          v small and far if far
          v big and close to exit when plr is close
          v smaller as plr gets really close
      v if close enough, draw star over player's head
        v grow with proximity to exit
        v pull player into exit orbit?


v Bug! I need to disable screen-lock in edit mode.
  Something about transition from test to edit?
v Bug in undo/redo for exit/entrance spirits.

v eliminate wall T-junctions and make edges meshy
  v start new BitRect to hold data and logic for bit rect conversions
    v without breaking everything
      v update every bitgrid user
      v createWorldRect() to do what BitGrid did
    v refactor BitGrid to use BitRect's createWorldRect
      v pull bitrect creation out into something the fan method can use later
  v fan basics
    v for now, just an array of Vec4
    v BitGrid can return a pile of fans
    v TileGrid can create models and stamps from said pile. Triangles for now since I don't really use GL fans.
      v Model.createFanFromVec4Array(list of v4s)
      v sanity-test by randomizing vertex colors?
  v optimize
    v detailed
      v don't add vertex at top/bottom if the opposite cell pair is solid+solid
        v but do add 'em every so often... every 4?
    x solid
      x create 16 different solid tile models, for each "is-neighbor-detailed" value, 2^4
      x live draw the right one based on the 4 neighbors - don't even bother caching?

v fix long midpoint-to-corner triangle edges by breaking up rects
  v chop fan rects every 8 bits! Then midpoints and chunks will be every 4, nice and even.
    v or every 4!

v Fix fragment shader interaction with distortion. Pass new x/y in, not original x/y.

v Add fragment shader wall rendering texture biz and make sure it distorts well

CONTROLS

empty-handed kick and grab
- kick
  v instant, not sustained
  x actual repulsor shotgun
    * tried it but didn't like it
  v rayscans instead of bullets! More efficient, faster, better graphics possibilities
  v splashes
    v splash-lines!
  - frequency limit
  - sound
- grab
  v rayscans instead of bullets
  v splashes
  - frequency limit
  - sound

v Fix bug where clicking stuff in pause mode triggers screen-lock

ENERGY AND ACTIVATION
Separate activation, which can trigger a device's power, from energy, which is a resource.
The player can activate a tool, and a sensor can activate a tool.
But "activation bullets" are no more.

v BaseSpirit
  * keep existing input/output/pulse biz for activation, but I doubt I'll need the pulses.
  v energy
    v setEnergy()
    v getEnergy()
    v setEnergyCapacity()
    v getEnergyCapacity()
    v addEnergy(), so the collider can call into energy-savvy spirits?
      v return overflow, negative for underflow, 0 for acceptance.
    x setEnergyDrainRate? Timer-based discrete addEnergy calls would be fine
v EnergyBullet
  v copy activation bullet, but it doesn't activate things, it powers them.
- EnergyWellSpirit
  - fires slow short-range energy pulses constantly
  - not portable!
- BatterySpirit
  - Holds up to $capacity of energy
  - Displays energy vs capacity
  - when triggered, fires short-range energy pulse from energy reserve, unless empty
- EnergyRedirectorSpirit
  * Small capacity
  * Constantly tries to fire long-range energy pulse from reserve, with some loss
- OpenerGun
  * feed it power to cut through a wall. Kind of a key/lock thing but different
  - immobile?
  - While powered it melts the wall it is pointed at? Limited range.
    - OpenerBullet? Or just rayscans and digging.
  - Uses a lot of power so you need to keep delivering power to cut through a thick wall.


- Pull drawTrail up to BaseSpirit.

- TickTockTrigger
  - alternately triggers and doesn't trigger the thing it's pointed at. Square-wave.
  - program it with a one-time run of triggering, from start to stop, which sets its interval
  * that way you can program one to match another one! Synchronize!

- Integration test
  - well feeds battery
  - tick-tock triggers battery
  - battery fuels redirector


- PlasmaSpirit
  - a fast flying projectile
  - kills player
  - kills enemies

- AntiPlayerPlasmaTurretSpirit
  - covers limited angle and range
  - scans for players (efficiently, cheating) and fires at 'em
  - requires energy - a little to scan, a lot to fire

- VanishingDoorSpirit
  - When powered all the way up, the door opens permanently

- WallEraserSpirit
  - When powered and triggered, it

PROPS & ITEMS

slime berries
- slime bullet
- slime effect
  -
- big monster eats slime-covered things
- pinball bumper fun when slimed!

fire
- blind periodic turret
- immovable explosive



OPTIMIZATION

- Re-use solid wall models



DECORATION

Vertex shaders
- pulse ring
- limit circle

- new exit sequence
  - when players in exit position, increase exit-ness
    - exit vacuum distortion
    - zoom in?
    - player-shaped splashes drifting towards exit center?
  - actual exitness is on a spring
  - dest exitness increases with continuous duration of player exit readyness
  - dest exitness resets to 0 if anyone leaves exit readyness
  - when dest exitness reaches threshold, then do final real no-effects exit

Effects
- pulse splashes
  - muzzle-flash when firing
  - 3-5 splash particles on wasted hit
  - cleaner flash on activation hit - circle? arrowhead? sparkles?
- fix weird noise when activator bullet hits player

- equipment continuity?
  - remember equipment on exit
  - restore equipment on entrance (but not on respawn!)

- entrance 3
  - continuation of player equipment
    (this is the real motive for making it to the exit, instead of dying and respawning. Plus honor I guess.)

  - warp in one player at a time, with queue
  - if players enqueued,
    - randomly pick rotation
    - rayscan for room for equipment and player
    - if room, place them both with quick diminishing-vacuum distort (mark both and only draw them with distortion)
    - else apply force to whatever the scan hit to try to make room

- beam shader
  - 2d mesh
  - params
    - endpoint positions
    - endpoint sizes
    - squash/stretch
    - wave magnitude, offset, and frequency

