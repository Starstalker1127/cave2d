2015-10-17
Mutable Terrain with BitGrid
v Nigh-infinite grid of cells
v drawPill
v getDirtyCells
v clearDirtyCells
v compress rects

2015-10-25
Game logic for mutable, explorable, yet limited terrain, v1.
All bodies will always be in memory, and all models will be in GL, but we'll only draw visible models.
v Load all dirty wall cells after level creation, and all adjacent uniform wall cells, so we get no gaps adjacent to
  dirty cells.
  v get x,y from cellId
v push-scroll camera - drag it so focal object (player body for now) is never more than X world dist away from camera.
v Draw each cell separately
  v Have separate GL models for every non-uniform cell.
    v cell def
      v BitGrid cellId
      v body id array (or null if bodies weren't loaded)
      v private GL model handle, or null if none
  x Use one model for uniform cells.
  x Draw solid cells that have no bodies? Or draw floor cells only? Kinda digging the floor idea.
v Draw every cell on the screen, and a little more for shader-distortion padding, but no more.
v mutation: unload and reload any loaded cells that change, and doublecheck adjacent cells.
  v Make bullets destroy terrain, to test mutation
Done 2015-10-28

Fix WorldEvent memory leak? Is it infinite-duration paths clogging up the event queue?
Nope. The problems were:
1) Tiny world cells probably sucked
2) Double-adding bodies when terrain changed was certainly bad.
3) Walls were declared to collide with themselves, which was wrong.
4) The event queue had events with times of Infinity. Good luck with that.
Done 2015-10-28 but nearly 24 hours later.

Cursor
v Set up new test33, with game1's tech mostly.
v Cursor movement: Same as game1 player, sans body (probably) and without worrying about collisions.
v Camera control: Also same as game1 player. (Hm. Extract common logic?)
v Hover detection and indicator
  v Render a ring
    v sweet sweet alpha blending
  v different cursor styles for each mode.
  v world.getOverlaps(body) returns list of bodies
  v Hover mode - what are we pointing at?:
    v pinpoint center check
      v if objects overlap, pick the one with the smallest area
      v Centered on wall block: WALL mode
    x broader check, objects only
      x If there are any, take the one with the lowest distance-to-surface.
    v finally, FLOOR mode
v Tweak cursor acceleration curves until it feels right.
Even more done, 2015-11-03

Trigger
v test34, copy of test33
v multitrigger
  v regular trigger
  v keytrigger
  v touchtrigger
  - add invisible touch trigger and key trigger to multitrigger and see if it goes.
    v multi keys down/up separately and are ORed together
    v unlisten works
    - touch trigger blocks touch trackball from eventing. order of add? zone function sharing?
v Use trigger in test for terrain editing.
  v triggerDown with wall/floor indicator starts floor/wall initial position, draws first pill.
  v drawPill from old to new position, then let old=new.
  v triggerUp ends it
- draw touchscreen trigger
  - circle on viewport coords, not world coords.
  ? only draw if there have been touch events in the last N seconds.
- Handle rotation/resize...
  - Track trigger pos as fraction of screen width/height, 0..1
  - Start at 0.9, 0.9
- Add trigger to game1 - no more auto-firing.

Refactor
- Pull up cursor/player accel logic from test33 and game1
- Pull up camera control too.

Dragging objects
- triggerDown centers cursor on object?
- dragging accelerates object? Or teleports it? Depends on distance?

save and load from string
- terrain: BitGrid s27n
- objects, positions, velocities

Add & delete objects
- Add action, menu... oh no, menus!
- Delete pseudomode

Particles
- test page - fireworks?
- game1 every kind of explosion
- game1 muzzle flash
- test33 digging

Tractor Beam
- game1 change gun to tractor beam
- game1 add tools
- game1 make critters grabbable

Bomb Factory

Rhythm Turret

Blipper

Beat Key

Secret Knock

Railgun

Mine

Bumper
