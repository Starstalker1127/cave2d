cave2d.com/<game path>/edit is the main editing UI, with adventures, levels, level editor, etc.
* Like Vorp, this is a single-page app with a hash-fragment query string.
  That means that the level editor's unzoomable meta tags need to be added/removed dynamically.
v Page baseclass
  v enterDoc
  v exitDoc
v AdventureListPage: If no adventure is found, clear the query and show the adventure list.
  v look in storage for paths like [<game>, "adventures", <adventure name>, ...]
  v show 'em in a list
  v "create" button for the whole list
  v for each row,
    v copy
    v rename
    v delete
    v hyperlink to enter adventure's levelList. URL: game2/edit/#adventure=<name>
v App class
  v hash fragment query parser
  v listen to hash fragment URL changes
  v ref to page now showing, to call exitDoc on it, then enter the new one.
v LevelListPage: If adventure is found but no level, show that adventure's level list.
  v link back to adventure list
v LevelEditorPage: If adventure and level are found, show that level's editor.
  * analagous to test38/main.js's starting point
  v update HTML
    v write canvas
    v write pause menu div
    v make Pages update body CSS
    v update and restore head meta viewport content
  v update pause menu
    v name of game, hyperlinked
    v name of adventure, hyperlinked
    v name of level
  v preload shader text files
    v make main.js pre-load shaders in a TextLoader
    v LEP either uses the shaders immediately or waits for a single callback.
    v copy RendererLoader code into LEP to create WebGL context.
  v create WebGL editor "screen"
  v save & load v1
    v load in enterDocument? Or when shaders are ready?
      v inject starting JSON into PlayScreen
      v if no JSON file, creation starts with mostly-empty default world
    v save on exitDocument
    v save on onBeforeUnload?
    x save occasionally
    v no sharable URL form now because that messes up the URL scheme. Add Import and Export later.
  v In mobile level editor, stop single-tap-button events from teleporting cursor!
  x exitDocument
    v stop listening
    x tear down WebGL, if it is set up, if nuking canvas doesn't do it already.

Export
I still like the idea of sharing a level by URL, but I also like sharing an adventure by JSON
/<game path>/export#, #adventure=xxx, and #adventure=xxx&level=YYY exports the relevant data to text which can be
copy/pasted into /game2/ file.
/<game path> is for playing the exported game.
v ExportPage
v Export link on each adventure.


Sprite configs...
A single spirit class, plus body, may have variations that result in multiple... what? Characters? Parts? Items?
* To distinguish them in the menu they should have different "icon" models, even if it's just color or size or minor
  variation.
* Serializing includes typeNum. Keep it in the spirit API.
* When deserializing, there should be a straight lookup from spiritType to (uniform) Spirit ctor. But it's many-to-one!
* Instances draw and make noise with Spirit code
...
* I guess a Spirit should be able to create a Model, using params.
* And a Spirit should be able to create a Stamp too, using params.
  * But cache 'em w PlayScreen "StampCache".
  * Cache key is all params that went into creating 'em.
* Menu configuration means...
   * creating Spirits with params and getting icon Models from 'em. OK.
   * having factory code for each menu item, to generate default values for spirit, body, etc
     to insert into world at x, y, d

SpiritConfig - one per spirit-type per game, concentrating the scattered Spirit stuff,
to help make coding a new spirit easier.
v Create a config that ties together the misc. sprite junk
  v type number (for serialization and deserialization) and also primary key for this game
  v stamp (just one? That'll change.) for rendering.
  v optional menu stuff. Maybe a list of these?
    v item name (why different from type number? Use type number?)
    v group
    v rank
    v model, for generating menu stamp
    v addFromMenuFactory
      v sets up default body
      v calls spirit constructor
      v overrides constructor biz maybe.
      v uses stamp
  v whatevs is needed for playscreen's fromJson()
    v deserializationFactory?
      v deserializes body
      v calls spirit constructor
      deserializes spirit state
      v uses stamp
  v menu creation
v Create one big map from spiritType to SpiritConfig
v Read from the SpiritConfigMap in all the right places in PlayScreen
v convert existing spirits
  v AntSpirit
  v PlayerSpirit

Modes - Edit, Test, Play
v rename PlayScreen to EditScreen
v change EditScreen "pause" button to "settings" or something
v Make TestScreen too
  v code nest
  v Button to get to it from Edit screen
  v css
  v camera follows average player-spirit position.
  v left-arrow button in TestScreen to navigate back to edit
v in edit mode,
  * collision interactions are limited to bouncing. No collecting, exposions, unlocking, exiting, etc.
  * Spirits may render differently, to help the editor position and orient them.
  * Leave the door open for spirits that help you make a level - diggers, sculptors, etc.
  v spirits don't move or create on their own.
  x Friction is applied uniformly by the editor?
v in test & play mode
  v player controls work
  v self-driving ant

super basic Player
Do I need a real Player object? It would get...
* some fraction of the screen for assigning a trackball and some buttons. 1/2, 1/4...
Then the player would own controls, and the screen would own the player? I guess?
And Player would have a collection of PlayerSpirits or whatevs to send control data to?
v PlayerSpirit shell
v timeout cycle
  v friction
v "Player" class, corresponds to a human player and their gameplay state
  v Controls passed in as state, mutable.
  v handleInput() reads controllers, dumbs down for Spirit and passes along to spirits, resets controls.
  v API for PlayerSpirit or other world entities added/removed by Screen, mutable state.
v TestScreen manages list of Players (just one for now), adds and removes, calls
  * start by adding player one's spirits and controls. Worry about death, respawn, and player 2+ later.
  v handleInput
    v call Player.handlInput
    v rewrite PlayerSpirit.handleInput a little
    v call at beginning of each RAF, before drawing or physics
      (BaseScreen already has handleInput() call, yay!
  v controls & layout hardcoded by screen for each # of players
    v one-player trackball
      v owned by screen, but reference held by player
        v on the world layer
        x screen does listen and unlisten
    v one-player buttons
      v two per player
      v on the HUD layer
      x listen and unlisten

Screen refactor
* Before adding PlayScreen and stuff, eliminate some redundancy.
v Pull common Test/Edit/Play stuff up to BaseScreen.
v move BaseScreen up to main dir, out of "edit".

PlayScreen
v make and export a few levels
v play uses big exported FileTree JSON file.
  v PlayPage loads adventure data via XHR
  v use as file tree
  v expose as adventure data
  v order the levels
v start with camera at avg of players, not wherever the editor left it.
v initialize the first level.
v in-game pause menu
  v start paused
  v resume, fullscreen
  v center
  v branding
  v change "resume" to "play"
  x clicking off of menu resumes? meh.
  v double-tap in the middle of the screen activates pause menu
    v sense mouse/touch down near middle of screen, hud layer, but do not consume event
    v onTap, when pauseTipEnd < now, pause is unexcited. Start excitement timer
    v Show pause button grow and then shrink through excitement arc
    v Tapping again during excitement
      v causes excitement to end
      v activate paused mode
    v unpausing causes fading mid-screen
  v user-test pause button. FAILED. even though it's hella fun. Oh well?

Pause button v3
v on play screen, put button near other buttons, just a regular widget I guess. :-/
  (wow that seemed like a lot of work)

Exit
v ExitSpirit
  v stamp looks like a square
    * yes that's lame and yes I feel bad
v SpiritConfig
v add to menu
v add to levels
v export levels
v in play mode, player hitting exit triggers...
  x transition screen? Some kinda pause feels right. But maybe later.
  v start next level
  v victory if there's no next level.
    v Gonna need a victory screen I guesssssss
v in test mode, uh... don't?
v friction in edit mode
  x add an onPulse like onTimeout, but free for everyone? Good time for friction, scans, etc.
v zero vel in play mode

Simply Stunning
players and gnomes can be stunned by accel (not force!) of collisions, even microcollisions
v track collision accel, "bang", over time
  v if we know the val at a time, then w a linear decay we can get at new time and mutate. Like paths.
    v setBangAtTime(v, t)
    v getBangAtTime(t)
    v floor is zero
    v any ceiling? Don't want perma-banged spirits just laying around, do we?
    v decay rate depends on spirit
    x make additional bang be the *square* of the collision accel? Will miro-collisions add up?
v stun is a function of bang
v stun level decreases voluntary control, may prevent actions when above a certain level.

polish for no reason
v zoom map in much more?
v tune stunning way the hell down

Scale ant-count by decreasing cost of off-screen ants
v don't draw them
v give them less frequent timeouts the further from the screen they are
  v with some max limit so they never look dead.
v bring them to a halt if their vel is very low
v if they're past a certain dist, just glide to a halt w/o rayscans.

v Victory v1

Player fire 1
v "X" button triggers it
  v throttle down to some limited frequency, w timeouts
- screen fire()
  v muzzle flash splash
  v create bullet
    v bullet spirit
      v temp model
      v drawing
      v splash trail?
        v prototype spark one using onDraw
        v better smarter Trail class
          v circ-buff of TrailSegment
          v TrailSegment with startTime startPos, vel
          v Trail itself has endTime that is often Infinity
        v use Trail in BulletSpirit
          v update Trail when trajectory changes
          v end Trail when bullet dies
          v don't delete BulletSpirit until it is done drawing the fading trail!
    - "pew" noise
- bullet behavior
  v vanish when hitting stuff or maybe bounce at low hit angles - start to add impact damage sys?
  - poof when hitting wall
  - wall damage?
  - damages enemies
    - enemy explosions

Player Death
- explosions and stuff
- temp slowdown?
- delay
- respawn

Gnome
- spirit
  - model
  - behavior
    - wander
    - chase
    - continue to last seen player position, like ye olde fracas 2
- config(s)
  - three strengths, three ranks

Gnome Generator
- spirit
  - model
  - behavior
    - wander
    - chase
    - continue to last seen player position, like ye olde fracas 2
- config(s)
  - three strengths, three ranks


Entrance, instead of player
- spawns a player in test/play mode
- if there's more than one, a random one is chosen as the starting point

Bombs
- explode when shot
- can be hidden inside walls, chain reaction opens new paths
- I guess every creature should be behind walls?

- Activate "pause" on touchscreen with doubletap in the center of the screen
  (keeps it out of the way of the edge-based player controls)
  - first tap shows auto-fading badge
  - second activates it

- Add and remove player 2
  - Player menu inside "pause" popup
    - row for existing players (room for all kinds of settings later)
      - rename
      - drop (except for the last player remaining)
    - add new

Make the player look cooler.
- Draw a little face on the player body
  - eyes follow trackball direction?

SplashConfig
* similar to SpiritConfig, except that there's no menu item for splashes

Orientation
- Bodies have orientation, moment of inertia, and angular velocity.
- create repeller turrets
- Cursor force can rotate bodies? Or cursor motion changes body orientation anyhow.
- editor

Measure actual framerate; don't assume it's 60fps.

Auto-save game in progress to localhost

TestScreen time controls
* centered on top. These are totally unneeded but probaby would be awesome.
- pause
- play 1/4 speed
- play regular speed
- play 4x speed? or faster?
- super speed

Custom dialogs:
- prompt
- confirm

Attribute editing?
- Spirits can expose a type+key: value form
- Mode button opens form editor

Test XX: Undo and Redo
- retain last N JSON serializations in RAM or wherevs.
- Create new ones using one-token-bucket throttle right before mutations, w 1/sec(realtime) restore rate.
- Always save the just-after mutation camera and cursor pos, to bring the area into focus before undoing.
  Keep that as a separate kind of undo record, since it's so tiny and easy to restore.
- Button for creating an undo record just because time went by. Snapshot?

Zoomable?
- two-touch pinch/unpinch
- mouse onscroll, like Vorp
- keys, maybe "[" and "]" or "," and "."
- Touching the zoom indicator buttons zooms to that level Maybe four: close, medium, wide, far.

Lifting?
- If cursor distance is too great for too long (low-pass average dist?), "lift" the object
- Lifted objects are treated as though they are uniform density, normal MOI, with no physics or collisions.
- Can lifted objects be sensed with rayscans? No, they're transferred to the "none" group.
- Only one object can be lifted at a time (worry about multi-user in the distant future).
- Lifting ends when you release the object.
* When time is frozen (upcoming feature), all object-movement is by lifting, because there is no time for physics.
* When adding objects, they are lifted as they leave the menu.
