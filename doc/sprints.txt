Code Harvesting
v WorldJsoner for s27n
  v write class
  v replace game2 code
  v replace game3 code
v TileGrid consolidation
  v move tile drawing to TileGrid
  x move terrain pill mutation to TileGrid (already done!)
v remove obsolete BaseScreen.flushTerrain func
v Prepare: prepend "GameX" and "TestX" to base, play, test, and edit screens for
  v t41
  v g3
  v t40
  v g2
- WorldScreen is the base of BaseScreen
  - Create comon WorldScreen class, borrowing from BaseScreen
    - default impls:
      - getSpiritConfigs()
      - getHitGroups()
      - getWallGroup()
      - getHitPairs()
      - clock()
      - draw()
      - resolveCollision()
  - Extend it in the XxxBaseScreen classes to eliminate a lot of code:
    - t41
    - g3
    - t40
    - g2
  - ??? Extend it in libs
    - WorldPlayScreen?
    - WorldEditScreen
    - WorldTestScreen
- World API
  - move body/spirit query stuff from basescreens to World
  - give Editor access to World, to remove a lot of editor->screen->world call routing? but Undo/redo in test41...
- Pages: pull the three main screen-having Page classes up
  - Play
  - Edit
  - Test
  - Pull most "pause" code up to those common pages
  - pull Fullscreen code up too

Solve the lastPathRefreshTime problem
Sometimes I want to add a body without also adding a spirit with a timeout loop just for invalidating the path.
Often I still want a spirit (for drawing or whatevs) but don't want to re-code the timeout loop.
Giving a body a maxPathDuration of Infinity cause tons of far-future collision events to be recorded,
effectively leaking them.
* Every movable body needs a Spirit chaperone w timeout invalidation loop?
* Add a common spirit behavior that registeres the timeout for me?
* Special world maxPathDuration=auto code?

Multiplayer
* up to four touch players
* Up to three keyboard players: wasd, ijkl, arrows
* Mouse control with pointerlock and keys?
* Gamepad controls if possible
- test42 nest
- PlayerInterface baseclass
  * Not many setters in the interface. The code's the thing. Subclass for particulars.
  * Doesn't own player spirit, position, etc.
  - onJoin()
    - touch controls add visible triggers
  - onDrop()
  - getJoinTriggerVal()
  - getGrabTriggerVal()
  - getThrowTriggerVal()
  - (later: getPackTriggerVal())
  - Trackball?
    - getTrackballValue()
    - getTrackballIsTouched()
  - setPauseListener() (so I don't need a Page to make a PI)
- Join
  - game loop listens for join trigger value down on unjoined players
  - joining adds a new PlayerCharacter, a Spirit with a PlayerInterface for controlling the Spirit.
  - PI.onJoin()
- Drop
  - Spirit listens for long hold on join trigger
  - remove spirit and stuff
  - PI.onDrop


chain constraints
Simple distance between two body positions - no offset from center, because rotation would make that harder...
Or allow off-center chain points, but only for short chains that never bend more than 90 degrees. Then
approximate angular motion as linear motion and solve for constraint-violation time that way. Guaranteed to remain
in-bounds, I think.
- jack data
- jack rendering
- link data
- link rendering
- editor
  - jack hover indicators
  - link-creation button
    - link type determined by jack type
  - link hover indicators
  - link deletion

Zoomable Editor
- two-touch pinch/unpinch
- mouse onscroll, like Vorp
- keys, maybe "[" and "]" or "," and "."
- Touching the zoom indicator buttons zooms to that level Maybe four: close, medium, wide, far.

World.processNextEvent fix
- fix all world.processNextEvent calls to not reference a freed event! Also maybe reset on free, not on alloc.

Layers
Mode switch between Terrain, Objects, and (soon) Snap
Things in common:
* add/fill and remove/dig
* position/clear pin (soon)
* menu for add
* cursor helps preview stuff
This'll simplify keyboard and touch button logiclayout

Pin
One button will position pin at the cursor, or clear it if you're close enough to it. So if you're not close,
double-tap will end up clearing it. The presence and position of the pin changes many actions you do,
like a shift key with coordinates.
Dig-line, fill-line, add (orientation), scale scalable objects, spin unscalable objects about a fixed point...
Later it can be used for creating links and chains


Snap
All objects can have snap-points that snap the cursor to them when close enough.
- Give all objects a snap-point in their centers, to make dragging w/o rotation easy.
- make snap points snap things, duh.
Snappers are world objects that only appear when editing, that are studded with snap points.
Since snappers often overlap with objects (no collisions!) there needs to be a way to separate grab-targets...
* separate "grab" for snappers and other objects?
* move overlapping points apart when the cursor is near more than one? Maybe with Z-shear effect?
  * I don't like targets that move when you hover.
  * so maybe make a deliberate z-shear
- snap menu
  - maybe a triangle of square grids, from 1x1 to 1x9 to 9x9
  - also some circles with a stud in the middle and studs at the edge: 3, 5, 6 (hex grid?!), 7, 9, 12, 16, 32, 64?
  - maybe shorter arcs too
- top-level switch to toggle snapping on/off? I can see it getting annoying when you're doing free-form dragging.

Batch rendering?
- Add vector versions of existing uniforms?
  -
Add "instanceNum" attrib to each vec?
... or extend "group" mechanism to support an array of model matrixes, and make a sweet polyline model with tons of groups??


Undo/Redo UX polish
- less crappy undo/redo button models
  - RigidModelLineDrawer
- save during a long change edit-gesture, like a digging drag, throttled by wall-time
- a bunch of stuff with view rectangles? Save it for when it's zoomable?

Test max RAF rate during pauses, to set max ms-before-bailing.
* This is to defend against devices that don't operate at 60 FPS.
* I can't base it on in-game performance because if code takes too long to do work, it can't tell that it should
  have used a shorter cutoff. It just looks like the correct cutoff is one frame longer than it really is.

Polygons (this will wreck my world so do at own risk)
- physics
  - represent segment
  - primitive static segment vs circle collision detection
  - represent concave polygon as complex body, lists of primitives with postion offsets
    - segments
    - corners
  - util for collapsing corners and segments of multiple convex into concave polys.
    - cull in-pointing corners
    - cull inner segments
- rendering
  - divide concave poly into convex chunks
- editing - polygrid, each tile containing N convex polys
  - bisect op
  - cut corner op
  - add - leave no overlap
  - subtract - use cut and bisect


