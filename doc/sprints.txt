Code Refactoring
v WorldJsoner for s27n
  v write class
  v replace game2 code
  v replace game3 code
v TileGrid consolidation
  v move tile drawing to TileGrid
  x move terrain pill mutation to TileGrid (already done!)
v remove obsolete BaseScreen.flushTerrain func
v Prepare: prepend "GameX" and "TestX" to base, play, test, and edit screens for
  v t41
  v g3
  v t40
  v g2
v WorldScreen is the base of BaseScreen: Part 1
  v Create common WorldScreen class, borrowing from BaseScreen
    v getSpiritConfigs()
    v getHitGroups()
    v getWallGroup()
    v getHitPairs()
    v clock()
    v draw()
    v onHitEvent()
    v keep stats but omit statmons
  v Extend it in the XxxBaseScreen classes to eliminate a lot of code
    v t41
      * hm, too much editor code remains...
v Move undo, redo, and pause from Test41EditScreen to Editor, but make undo/redo optional
  v t41
  v fix other Editor users by removing their Pause code
    v t40
    v t39
    v t38
    v t37
    v g2
    v g3
v Make all Editor callers supply spiritConfigs, and make spiritConfigs mandatory
  v t40
  v t39
  x t38 deleted!
  v t37 (empty map)
  v g2
  v g3
v WorldScreen is the base of BaseScreen: Part 2
  * delete screen's addItem()
  v t40
  v g2: This is the big one.
  x g3? Do I have it in me? g2 was a lot of work. leave g3 for now.
v Add Undo to game editors
  v g2
  x g3? meh.
v Remember undo/redo when switching between edit and test.
  * don't overdo it. Just make it so that a one-window users can make a change, test, untest, and undo.
  v when saving level to json
    v put a random changestack token into the JSON
    v store the changestack in app RAM using that token
      * survives level renames
      * never gives the wrong changestack to an edit screen
      * SessionStorage requires JSONing and that seems overkill
  v when loading from json in edit mode
    v get the token from JSON
    v look for the changestack JSON
    v If it exists, initialize the world's ChangeStack using the result
v BUG: editor, add ant, remove ant, test, untest, undo (to re-add ant), test. Ant can be seen but never moves!
  * also works w player. Clear that timeout loop is broken!
  * pretty definitely to do with timeouts...
v Pages: Reduce redundant code
  v Make an app-level ScreenPage baseclass for (game2) pages with screens
  v Extend it:
    v Play
    v Edit
    v Test

Better undo/redo icons
v square-turn arrows are OK, you clunky so-and-so.

Game4: Multiplayer Tractorbeam 1
* up to four touch players
* Up to three keyboard players: wasd, ijkl, arrows
* Mouse control with pointerlock and keys?
* Gamepad controls if possible
v game4 nest, copy of game2
v spirits
  v make ants use proper rotation
    v use body rotation to store self
    v actually respond to torque and use angular momentum correctly
  x make player use proper rotation too // nah, gonna nuke and restart player spirit code anyhow.
v undo bug! Can't redo sometimes.
  It was because I wasn't stopping ant angular velocity, and also wasn't stopping ExitSpirit velocity because bugs.
  To debug I added the line graphs to game4, and I'll leave 'em in.

Test 42: Multiplayer Controls
v nest
v PlayerControls (NOT in charge of joining game)
  v stick, triggers
  v spirit setter
  v calls spirit's handleInput
v PlayerSlot
  v join trigger
    v multitrigger of KeyTriggers for keyboard slot
    v TriggerWidget for touch slot
  v enable()
    v status disabled --> enabled
    v enable the join triggers
  v join()
    v status enabled --> playing
    v disable the join triggers
    v enable the control triggers
  v leave()
    v status playing --> disabled
    v enable the join triggers
    v disable the control triggers
  v disable()
    v leave() if not already left
    v disable the join triggers
  v test w two keyboard players
- touch players
  - drawHud()
    - join button if waiting
    - b1 and b2 if playing

Solve the lastPathRefreshTime problem
Sometimes I want to add a body without also adding a spirit and timeout loop just for invalidating the path.
Often I still want a spirit (for drawing or whatevs) but don't want to re-code the timeout loop.
Giving a moving body a maxPathDuration of Infinity causes tons of far-future collision events to be recorded,
effectively leaking them.
* Every movable body needs a Spirit chaperone w timeout invalidation loop?
* Add a common spirit behavior that registers the timeout for me?
* Special world maxPathDuration=auto code? nah

More refactoring...
- Inject collider info into baseScreen from pages, instead of using "createXXX" overrides?
- World API
  - move body/spirit query stuff from basescreens to World
  - give Editor access to World, to remove a lot of editor->screen->world call routing??


chain constraints
Simple distance between two body positions - no offset from center, because rotation would make that harder...
Or allow off-center chain points, but only for short chains that never bend more than 90 degrees. Then
approximate angular motion as linear motion and solve for constraint-violation time that way. Guaranteed to remain
in-bounds, I think.
- jack data
- jack rendering
- link data
- link rendering
- editor
  - jack hover indicators
  - link-creation button
    - link type determined by jack type
  - link hover indicators
  - link deletion

Zoomable Editor
- two-touch pinch/unpinch
- mouse onscroll, like Vorp
- keys, maybe "[" and "]" or "," and "."
- Touching the zoom indicator buttons zooms to that level Maybe four: close, medium, wide, far.

World.processNextEvent fix
- fix all world.processNextEvent calls to not reference a freed event! Also maybe reset on free, not on alloc.

Layers
Mode switch between Terrain, Objects, and (soon) Snap
Things in common:
* add/fill and remove/dig
* position/clear pin (soon)
* menu for add
* cursor helps preview stuff
This'll simplify keyboard and touch button logiclayout

Pin
One button will position pin at the cursor, or clear it if you're close enough to it. So if you're not close,
double-tap will end up clearing it. The presence and position of the pin changes many actions you do,
like a shift key with coordinates.
Dig-line, fill-line, add (orientation), scale scalable objects, spin unscalable objects about a fixed point...
Later it can be used for creating links and chains

Snap
All objects can have snap-points that snap the cursor to them when close enough.
- Give all objects a snap-point in their centers, to make dragging w/o rotation easy.
- make snap points snap things, duh.
Snappers are world objects that only appear when editing, that are studded with snap points.
Since snappers often overlap with objects (no collisions!) there needs to be a way to separate grab-targets...
* separate "grab" for snappers and other objects?
* move overlapping points apart when the cursor is near more than one? Maybe with Z-shear effect?
  * I don't like targets that move when you hover.
  * so maybe make a deliberate z-shear
- snap menu
  - maybe a triangle of square grids, from 1x1 to 1x9 to 9x9
  - also some circles with a stud in the middle and studs at the edge: 3, 5, 6 (hex grid?!), 7, 9, 12, 16, 32, 64?
  - maybe shorter arcs too
- top-level switch to toggle snapping on/off? I can see it getting annoying when you're doing free-form dragging.

Batch rendering?
- Add vector versions of existing uniforms?
  -
Add "instanceNum" attrib to each vec?
... or extend "group" mechanism to support an array of model matrixes, and make a sweet polyline model with tons of groups??


Undo/Redo UX polish
v less crappy undo/redo button models
  x RigidModelLineDrawer
- save during a long change edit-gesture, like a digging drag, throttled by wall-time
- a bunch of stuff with view rectangles? Save it for when it's zoomable?

Test max RAF rate during pauses, to set max ms-before-bailing.
* This is to defend against devices that don't operate at 60 FPS.
* I can't base it on in-game performance because if code takes too long to do work, it can't tell that it should
  have used a shorter cutoff. It just looks like the correct cutoff is one frame longer than it really is.

Polygons (this will wreck my world so do at own risk)
- physics
  - represent segment
  - primitive static segment vs circle collision detection
  - represent concave polygon as complex body, lists of primitives with postion offsets
    - segments
    - corners
  - util for collapsing corners and segments of multiple convex into concave polys.
    - cull in-pointing corners
    - cull inner segments
- rendering
  - divide concave poly into convex chunks
- editing - polygrid, each tile containing N convex polys
  - bisect op
  - cut corner op
  - add - leave no overlap
  - subtract - use cut and bisect


