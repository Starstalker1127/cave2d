cave2d.com/<game path>/edit is the main editing UI, with adventures, levels, level editor, etc.
* Like Vorp, this is a single-page app with a hash-fragment query string.
  That means that the level editor's unzoomable meta tags need to be added/removed dynamically.
v Page baseclass
  v enterDoc
  v exitDoc
v AdventureListPage: If no adventure is found, clear the query and show the adventure list.
  v look in storage for paths like [<game>, "adventures", <adventure name>, ...]
  v show 'em in a list
  v "create" button for the whole list
  v for each row,
    v copy
    v rename
    v delete
    v hyperlink to enter adventure's levelList. URL: game2/edit/#adventure=<name>
v App class
  v hash fragment query parser
  v listen to hash fragment URL changes
  v ref to page now showing, to call exitDoc on it, then enter the new one.
v LevelListPage: If adventure is found but no level, show that adventure's level list.
  v link back to adventure list
- LevelEditorPage: If adventure and level are found, show that level's editor.
  * analagous to test38/main.js's starting point
  v update HTML
    v write canvas
    v write pause menu div
    v make Pages update body CSS
    v update and restore head meta viewport content
  v update pause menu
    v name of game, hyperlinked
    v name of adventure, hyperlinked
    v name of level
  v preload shader text files
    v make main.js pre-load shaders in a TextLoader
    v LEP either uses the shaders immediately or waits for a single callback.
    v copy RendererLoader code into LEP to create WebGL context.
  v create WebGL editor "screen"
  v save & load v1
    v load in enterDocument? Or when shaders are ready?
      v inject starting JSON into PlayScreen
      v if no JSON file, creation starts with mostly-empty default world
    v save on exitDocument
    v save on onBeforeUnload?
    x save occasionally
    v no sharable URL form now because that messes up the URL scheme. Add Import and Export later.
  v In mobile level editor, stop single-tap-button events from teleporting cursor!
  x exitDocument
    v stop listening
    x tear down WebGL, if it is set up, if nuking canvas doesn't do it already.

Export
I still like the idea of sharing a level by URL, but I also like sharing an adventure by JSON
/<game path>/export#, #adventure=xxx, and #adventure=xxx&level=YYY exports the relevant data to text which can be copy/pasted into /game2/ file
/<game path> is for playing the exported game.
v ExportPage
v Export link on each adventure.

Basic Parts
- Player
- Exit

Level Play Progression
- make and export a few levels
- play uses big exported FileTree JSON file, read via XHR.
- game2/ adventure list, from FileTree.
- click on adventure to play levels in alpha order
  - game2/#adv=foo&level=bar plays that level? Or keep it all in memory, no bookmarking?
- in-game pause menu - resume, fullscreen, quit
- victory page?

Orientation
- Bodies have orientation, moment of inertia, and angular velocity.
- create repeller turrets
- Cursor force can rotate bodies? Or cursor motion changes body orientation anyhow.
- editor

Attribute editing?
- Spirits can expose a type+key: value form
- Mode button opens form editor

Test XX: Undo and Redo
- retain last N JSON serializations in RAM or wherevs.
- Create new ones using one-token-bucket throttle right before mutations, w 1/sec(realtime) restore rate.
- Always save the just-after mutation camera and cursor pos, to bring the area into focus before undoing.
  Keep that as a separate kind of undo record, since it's so tiny and easy to restore.
- Button for creating an undo record just because time went by. Snapshot?

Zoomable?
- two-touch pinch/unpinch
- mouse onscroll, like Vorp
- keys, maybe "[" and "]" or "," and "."
- Touching the zoom indicator buttons zooms to that level Maybe four: close, medium, wide, far.

Lifting?
- If cursor distance is too great for too long (low-pass average dist?), "lift" the object
- Lifted objects are treated as though they are uniform density, normal MOI, with no physics or collisions.
- Can lifted objects be sensed with rayscans? No, they're transferred to the "none" group.
- Only one object can be lifted at a time (worry about multi-user in the distant future).
- Lifting ends when you release the object.
* When time is frozen (upcoming feature), all object-movement is by lifting, because there is no time for physics.
* When adding objects, they are lifted as they leave the menu.
