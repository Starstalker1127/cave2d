Game2 refactoring I
v pull up menuitemconfig to cave2d lib
v pull up spiritconfig to cave2d lib
v break up game2/basescreen a bit.
  * baseScreen won't be re-used, but it will be copied
  * some useful code can be extracted from it for true re-use
  * it can be made smaller and more template-y.
  v sounds as plugin
    v put sound effect code in it's own file
    v call screen.sounds.foo() - remove screen sound methods
      yeah yeah Law of Demeter... Adding a param to every Spirit is a PITA. Not gonna do it.
  v stamps as plugin
    v glyphs
    v generic shapes like "tube"
    x spirit config stamps?
    v replace uses, violate Law of Demeter, but mainly in reset() methods, where fields are extracted from screen obj
  v replace screenXXX.lazyInit
    v make it deliberate, not lazy
    v unpack calls into the pages that build screens
      v play
      v edit
      v test

Make basic app page-creation configurable.
v rename
  v LevelEditorPage to EditLevelPage
  v LevelTestPage to TestLevelPage
  v LevelPlayPage to PlayLevelPage
v Move to game2
  v EditLevelPage
  v TestLevelPage
  v PlayLevelPage
v EditorApp
  v inject EditLevelPage ctor
  v inject TestLevelPage ctor
v PlayApp
  v inject PlayLevelPage ctor

Game2 BaseScreen refactoring II
v generalize wall tile code: TileGrid yay!
x generalize level JSON deserislization logic
x generalize controls setup?
x generalize dom event handling (listen, unlisten, distributor setup)
x phy stuff
  x groups setup
  x collision handling
  x scan util

Test 39: Orientation & off-center force
v test nest based on previous editor tests
v Start over? nest based on game2 edit app?
v prepare nest
  v remove the multi-adventure multi-level bits. Just one level and adventure.
  v remove test switch
  v edit and play at the same time
v change spirits
  v remove exit
  v remove player
  v remove bullet
v body values
  v moi
  v "turnable" boolean? - default undefined means no?
  v angStart
  v angTime
  v angVel
  v getAngPosAtTime()
  v setAngPosAtTime()
  v setAngVelAtTime()
v make AntSpirit use new rotation system
v editor
  v grab objects at a point, and apply force to that point when dragging
    v point defined by dist & direction from center of mass.
  v give cursor a direction based on movement
  v add objects with initial orientation based on cursor direction
  v s27n

Surface collision grip
v calc contact point of collision
  v hitresolver stuff
  v game2 tweaks
v "surfaceGrip" in body
  * 0: frictionless, like a bowling ball
  * 0.3: fair amount of friction, like a dirty tire
  * 0.5: very grippy, a clean basketball
  * 1: 100% elastic, like a superball
  There are more realistic characterizations...
  A superball will grip a bowling ball and a wood floor
  but a bowling ball will not grip a wood floor
  so there's smoothness, stickyness, tread...
  there's also grip decrease as surface vel increases, like tires gripping vs slipping
  and grip is a function of pressure too. arrr
  Basically grip is a function of both surfaces, the surface velocity, pressure, hardness...
v collision response
  v calculate surface velocity vec
  v calc force to totally reverse surface vec
  v then mult by product of surface grips
  v apply those forces at edges of objects
  v really solve for force. Math works!
  v debug it. Energy is not being conserved?
    v end surface velocities will be ~equal if grip==1
    v energy conserved or reduced a little

Game3 prototype
Rolling (& jumping?)
Simple game with same old level editor and junk.
left, right, jump
reach the exit
gravity, obstacles
v copy game2 to game3
v player v1 - angular accel

Stats 2016-11-06 to 11-16
v Stats class path-delimited key/value pairs for tracking values now - no history. Really dumb.
v StatTrail class can record stat value/time pairs in a circular buffer.
v StatRateTrail class subclasses StatTrail, first derivative.
v StatGraph class can render a StatTrail

LineDrawer 2016-11-13 to 11-16
This will alternate the moving end between group 1 and group 2. That's the only fancy part.
Use renderer's matrix and color API - don't replicate.
v takes a renderer and a stamp - probably a closed cylinder, but anything with two groups is good
v moveToXYZR(x, y, z, r) // remembers but doesn't draw
v lineToXYZR(x, y, z, r) // draws from prev, moves prev to current
v test page

Graphing improvements
v make the lines equal width and height
  v make the view matrix match upside-down Sector I 2d coords 0, 0 to width-1, height-1
  v include an expected time domain
    v render time with now on the right and the past on the left
  v include an expected value range
  v use a Rect to show where the graph goes on the plane
  v make sure the line thickness is at least 2 pixels, for our unantialiased friends
v refactor and encapsulate, for multiple graphs
  v add a StatMon class
    v holds a Trail and a Graph, but manages both
    v sample() for the trail
      v knows how to read its own time and val
    v draw(canvasWidth, canvasHeight) for the graph
      v lazily updates internal view matrix, but always sets renderer view matrix
    v SAMPLE_PERIOD_FRAMES becomes "sampleInterval", internal to sample()
    v sampleCount is for trail and graph
    v graph value range
v convert test40 to use StatMon

Layout system
v new Cuboid class, not rects, because Z is not to be ignored.
v new CuboidRule(source, target) for setting target cuboid's position and radii based on another cuboid
  v size
    v setSizingMax(maxParentRads, maxPixels) // Vec4s. the system takes the min of these in each dimension
      v aspect ratio locking can make things even smaller, never larger
    v setAspectRation(ratio) // optionally lock target aspect ratio. A zero means that the dimension is unconstrained.
  v position - the target will be moved so the two anchors are at the same position
    v setTargetAnchor(rads, pixels) // Vec4s. Anchor pos on target = rad*rads + pixels
    v setSourceAnchor(rads, pixels) // Vec4s. Anchor pos on source = rad*rads + pixels
  v apply()
    v unit-test
      v size
      v aspect ratio
      v anchors
v layout statgraphs using cuboids instead of rects
  v ditto, therefore, for statmon
  v higher z is closer to user, on top of lower z
v apply rules to canvas and two graphs
v add borders back

v enhance StatMon
  v graphposition and size on screen
  v graphcolor
  v graph z
  v graphline width
  v graphborder
    x graphwidths
    v graphcolor
  x graphgridlines?
  x graphmin/max indicators? Or values at least?
  x graphcurrent value text?

v more stats 'n' graphs
  v frame stats
    v time drawing
    v time clocking
    v time between frames (should be steady with occasional spikes)
    v second slower timescale to the left. Never seen that before but I want it.
      (did it and undid it. could do it again)
  x world stats
    x valid collisions
    x invalid collisions
    x valid cell entry/exit events
    x invalid cell entry/exit events
    x timeouts
    x rayscans
  x renderer stats
    x real GL call counts? Hard because GLs get passed around more than renderer.
  x memory
    x pool allocs/frees for various classes

Editor & Trigger refactor
v pull stamps-making code into separate file
v debug missing keyboard shortcuts
v replace Editor trigger layout code with a canvas cuboid, trigger cuboids, and some rules, and cuboid/trigger glue
  v Triggers
    v layout
      v use a cuboid reference for layout
      v getCuboid returns ref to internal cuboid, for rules to target
      v remember last used cuboid layout, and update automatically when drawing if there's a diff
      v remove other APIs!
    v key tip
      v take CuboidRule for laying out tip
      v reasonable default
      v remove other key tip layout APIs
  v migrate widget users to Cuboid (but maybe not CuboidRule)
    v test37 pause widget
    v test38 pause widget
    v test39 pause widget
    v test40 pause widget
    v Editor
      v canvas cuboid
      v each trigger cuboid max y 1/6, max Y 50px, 1:1, anchor offset Y 1/10 of target.
        * no need for wrapper cuboids hahaha!
      v list of rules
      v apply in updateHudLayout
    v game2
      v player triggers
      v editscreen pause and test
      v testscreen untest
    v game3
      x delete player triggers because we don't need 'em
      v editscreen pause and test
      v testscreen untest
      v fix test/untest keyboard shortcut


Undo/Redo
v design button layout
  * undo/redo will go on top to the right of the tabs and left of the pause button
v test41 nest
v quiet stillness, to reduce diffs so you're not unwinding a bunch of involuntary physics-over-time changes
  v set frictions very high while editing. 100%? No motion beyond active editing.
  v stop vel when vel is less than TEENY_VEL
    v zero vel
    x stop friction timeouts (or maybe one less reason - see angvel below)
    x set path duration to infinity
  v stop rotation when angvel is less than TEENY_ANGVEL
    v zero angvel
    x stop angvel timeouts (or one less reason to do friction timeout)
  x wake when accelerated (linear or angular)
    x start timeouts again
  * It's OK to let time move fwd, if that's the *only* thing moving fwd. But...
  x maybe don't move time fwd if nothing is moving and nothing is planned. That's an Eternal Stillness Condition
  v actually don't move forward if nothing's moving. Ignore timeouts!
v SaveStack
  v class nest
  v circular buffer of saves
  v "depth" is usually 0 but higher numbers mean
  v save(world, view)
    v pop "depth" times to nuke any redos (the worst part if I remain traditional)
    v set depth to 0
    v push(aka enqueue) the world/view pair into the stack
  v view peeks
    v getView(1) // undo
    v getView(-1) // redo
  v canRestore(dir) return  0 <= undoDepth + dir <= queue.size() - 1
  v selectWorld(dir)
    v inc/dec undoDepth if possible
    v return world or null
v Buttons
  v undo button
  v redo button
- EditScreen should save at appropriate times
  v world dirty bit: always know if any world state changed since the last save
    v EditScreen.isDirty()
    v EditScreen.setDirty()
    v world-time advance
    v terrain change bit
    v add/remove
  - when the user hits undo/redo
    - halt ongoing edit gestures
    - stop all motion and rotation. Otherwise, a setWorld() to a state in motion would instantly re-dirty the world.
    - if there were any changes, saveStack.save()
    - getView(dir)
    - if view is close enough,
      - selectWorld(dir)
      - apply it.
    - else set the view only
  - save when the world is dirty and has settled on its own
  - save during a long change edit-gesture, like a digging drag, throttled by wall-time?
- editSceen.setGame() v1
  - clear world and rebuild everything, regardless
- setGame() v2
  - don't clear world
  - terrain cellwise bitgrid diff: added, removed, changed
  - non-terrain bodies - compare serialized forms
  - non-terrain spirits
  - timeouts - ditto
- less crappy undo/redo button models
- optimizations
  - maybe separate terrain changes from spirit & body changes, to avoid dealing with a mass of unchanged data?
    Or not. It would make an Save record a "change" not a "state" and then the direction of time would matter. AA -> AB -> BB
    But a memoized state could prevent deeper checking and not introduce "change" objects.
    And if states are immutable then reference sharing is OK, to reduce mem cost.

World.processNextEvent fix
- fix all world.processNextEvent calls to not reference a freed event! Also maybe reset on free, not on alloc.

Layers
Mode switch between Terrain, Objects, and (soon) Snap
Things in common:
* add/fill and remove/dig
* position/clear pin (soon)
* menu for add
* cursor helps preview stuff
This'll simplify keyboard and touch button logiclayout

Pin
One button will position pin at the cursor, or clear it if you're close enough to it. So if you're not close,
double-tap will end up clearing it. The presence and position of the pin changes many actions you do,
like a shift key with coordinates.
Dig-line, fill-line, add (orientation), scale scalable objects, spin unscalable objects about a fixed point...
Later it can be used for creating links and chains


Snap
All objects can have snap-points that snap the cursor to them when close enough.
- Give all objects a snap-point in their centers, to make dragging w/o rotation easy.
- make snap points snap things, duh.
Snappers are world objects that only appear when editing, that are studded with snap points.
Since snappers often overlap with objects (no collisions!) there needs to be a way to separate grab-targets...
* separate "grab" for snappers and other objects?
* move overlapping points apart when the cursor is near more than one? Maybe with Z-shear effect?
  * I don't like targets that move when you hover.
  * so maybe make a deliberate z-shear
- snap menu
  - maybe a triangle of square grids, from 1x1 to 1x9 to 9x9
  - also some circles with a stud in the middle and studs at the edge: 3, 5, 6 (hex grid?!), 7, 9, 12, 16, 32, 64?
  - maybe shorter arcs too
- top-level switch to toggle snapping on/off? I can see it getting annoying when you're doing free-form dragging.


Test max RAF rate during pauses, to set max ms-before-bailing.
* This is to defend against devices that don't operate at 60 FPS.
* I can't base it on in-game performance because if code takes too long to do work, it can't tell that it should
  have used a shorter cutoff. It just looks like the correct cutoff is one frame longer than it really is.

Polygons (this will wreck my world so do at own risk)
- physics
  - represent segment
  - primitive static segment vs circle collision detection
  - represent concave polygon as complex body, lists of primitives with postion offsets
    - segments
    - corners
  - util for collapsing corners and segments of multiple convex into concave polys.
    - cull in-pointing corners
    - cull inner segments
- rendering
  - divide concave poly into convex chunks
- editing - polygrid, each tile containing N convex polys
  - bisect op
  - cut corner op
  - add - leave no overlap
  - subtract - use cut and bisect


Multiplayer
* up to four touch players
* Up to three keyboard players: wasd, ijkl, arrows
* Gamepad controls if possible
Player modes: Absent, Wispy, Embodied

chain constraints
Simple distance between two body positions - no offset from center, because rotation would make that harder...
Or allow off-center chain points, but only for short chains that never bend more than 90 degrees. Then
approximate angular motion as linear motion and solve for constraint-violation time that way. Guaranteed to remain
in-bounds, I think.
- jack data
- jack rendering
- link data
- link rendering
- editor
  - jack hover indicators
  - link-creation button
    - link type determined by jack type
  - link hover indicators
  - link deletion

Zoomable Editor
- two-touch pinch/unpinch
- mouse onscroll, like Vorp
- keys, maybe "[" and "]" or "," and "."
- Touching the zoom indicator buttons zooms to that level Maybe four: close, medium, wide, far.
