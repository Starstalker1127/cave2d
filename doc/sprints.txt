Game2 refactoring I
v pull up menuitemconfig to cave2d lib
v pull up spiritconfig to cave2d lib
v break up game2/basescreen a bit.
  * baseScreen won't be re-used, but it will be copied
  * some useful code can be extracted from it for true re-use
  * it can be made smaller and more template-y.
  v sounds as plugin
    v put sound effect code in it's own file
    v call screen.sounds.foo() - remove screen sound methods
      yeah yeah Law of Demeter... Adding a param to every Spirit is a PITA. Not gonna do it.
  v stamps as plugin
    v glyphs
    v generic shapes like "tube"
    x spirit config stamps?
    v replace uses, violate Law of Demeter, but mainly in reset() methods, where fields are extracted from screen obj
  v replace screenXXX.lazyInit
    v make it deliberate, not lazy
    v unpack calls into the pages that build screens
      v play
      v edit
      v test

Make basic app page-creation configurable.
v rename
  v LevelEditorPage to EditLevelPage
  v LevelTestPage to TestLevelPage
  v LevelPlayPage to PlayLevelPage
v Move to game2
  v EditLevelPage
  v TestLevelPage
  v PlayLevelPage
v EditorApp
  v inject EditLevelPage ctor
  v inject TestLevelPage ctor
v PlayApp
  v inject PlayLevelPage ctor

Game2 BaseScreen refactoring II
v generalize wall tile code: TileGrid yay!
x generalize level JSON deserislization logic
x generalize controls setup?
x generalize dom event handling (listen, unlisten, distributor setup)
x phy stuff
  x groups setup
  x collision handling
  x scan util

Test 39: Orientation & off-center force
v test nest based on previous editor tests
v Start over? nest based on game2 edit app?
v prepare nest
  v remove the multi-adventure multi-level bits. Just one level and adventure.
  v remove test switch
  v edit and play at the same time
v change spirits
  v remove exit
  v remove player
  v remove bullet
v body values
  v moi
  v "turnable" boolean? - default undefined means no?
  v angStart
  v angTime
  v angVel
  v getAngPosAtTime()
  v setAngPosAtTime()
  v setAngVelAtTime()
v make AntSpirit use new rotation system
v editor
  v grab objects at a point, and apply force to that point when dragging
    v point defined by dist & direction from center of mass.
  v give cursor a direction based on movement
  v add objects with initial orientation based on cursor direction
  v s27n

Surface collision grip
v calc contact point of collision
  v hitresolver stuff
  v game2 tweaks
v "surfaceGrip" in body
  * 0: frictionless, like a bowling ball
  * 0.3: fair amount of friction, like a dirty tire
  * 0.5: very grippy, a clean basketball
  * 1: 100% elastic, like a superball
  There are more realistic characterizations...
  A superball will grip a bowling ball and a wood floor
  but a bowling ball will not grip a wood floor
  so there's smoothness, stickyness, tread...
  there's also grip decrease as surface vel increases, like tires gripping vs slipping
  and grip is a function of pressure too. arrr
  Basically grip is a function of both surfaces, the surface velocity, pressure, hardness...
v collision response
  v calculate surface velocity vec
  v calc force to totally reverse surface vec
  v then mult by product of surface grips
  v apply those forces at edges of objects
  v really solve for force. Math works!
  v debug it. Energy is not being conserved?
    v end surface velocities will be ~equal if grip==1
    v energy conserved or reduced a little

Game3 prototype
Rolling (& jumping?)
Simple game with same old level editor and junk.
left, right, jump
reach the exit
gravity, obstacles
v copy game2 to game3
v player v1 - angular accel

Stats 2016-11-06 to 11-16
v Stats class path-delimited key/value pairs for tracking values now - no history. Really dumb.
v StatTrail class can record stat value/time pairs in a circular buffer.
v StatRateTrail class subclasses StatTrail, first derivative.
v StatGraph class can render a StatTrail

LineDrawer 2016-11-13 to 11-16
This will alternate the moving end between group 1 and group 2. That's the only fancy part.
Use renderer's matrix and color API - don't replicate.
v takes a renderer and a stamp - probably a closed cylinder, but anything with two groups is good
v moveToXYZR(x, y, z, r) // remembers but doesn't draw
v lineToXYZR(x, y, z, r) // draws from prev, moves prev to current
v test page

Graphing improvements
v make the lines equal width and height
  v make the view matrix match upside-down Sector I 2d coords 0, 0 to width-1, height-1
  v include an expected time domain
    v render time with now on the right and the past on the left
  v include an expected value range
  v use a Rect to show where the graph goes on the plane
  v make sure the line thickness is at least 2 pixels, for our unantialiased friends
- refactor and encapsulate, for multiple graphs
  - add a StatMon class
    - holds a Trail and a Graph, but manages both
    - sample() for the trail
      - knows how to read its own time and val
    - draw(canvasWidth, canvasHeight) for the graph
      - lazily updates internal view matrix, but always sets renderer view matrix
    v SAMPLE_PERIOD_FRAMES becomes "sampleInterval", internal to sample()
    v sampleCount is for trail and graph
    - graphTimespan (domain roughly)
    - graph value range
    - position and size on screen
    - color
    - z
    - line width
    - border
      - widths
      - color
    - gridlines?
    - min/max indicators? Or values at least?
    - current value text?
- convert test40 to use StatMon
- multiple stats
  - frame stats
    - time clocking
    - time drawing
    - time between frames (should be steady with occasional spikes)
    - second slower timescale to the left. Never seen that before but I want it.
  - world stats
    - valid collisions
    - invalid collisions
    - valid cell entry/exit events
    - invalid cell entry/exit events
    - timeouts
    - rayscans
  - renderer stats
    - draw() calls
  - memory
    - pool allocs/frees for various classes

Test max RAF rate during pauses, to set max ms-before-bailing

Undo/Redo
- quiet stillness, to reduce diffs so you're not unwinding a bunch of involuntary physics-over-time changes
  - set frictions very high while editing. 100%? No motion beyond active editing.
  - stop vel when vel is less than TEENY_VEL
    - zero vel
    - stop friction timeouts (or maybe one less reason - see angvel below)
    - set path duration to infinity
  - stop rotation when angvel is less than TEENY_ANGVEL
    - zero angvel
    - stop angvel timeouts (or one less reason to do friction timeout)
  - wake when accelerated (linear or angular)
    - start timeouts again
  * It's OK to let time move fwd, if that's the *only* thing moving fwd. But...
  - maybe don't move time fwd if nothing is moving and nothing is planned. That's an Eternal Stillness Condition
- record snapshots...
  - if the camera moved a lot since the last snapshot, take a snap right before an edit-gesturee takes effect.
  - when an edit-gesture has ended
  - during a long change edit-gesture, like a digging drag, throttled by time or change-count.
- setGame()
  - terrain cellwise bitgrid diff: added, removed, changed
  - non-terrain bodies - compare serialized forms
  - non-terrain spirits
  - timeouts - ditto
- undo button
- redo button

Layers
Mode switch between Terrain, Objects, and (soon) Snap
Things in common:
* add/fill and remove/dig
* position/clear pin (soon)
* menu for add
* cursor helps preview stuff
This'll simplify keyboard and touch button logiclayout

Pin
One button will position pin at the cursor, or clear it if you're close enough to it. So if you're not close,
double-tap will end up clearing it. The presence and position of the pin changes many actions you do,
like a shift key with coordinates.
Dig-line, fill-line, add (orientation), scale scalable objects, spin unscalable objects about a fixed point...
Later it can be used for creating links and chains


Snap
All objects can have snap-points that snap the cursor to them when close enough.
- Give all objects a snap-point in their centers, to make dragging w/o rotation easy.
- make snap points snap things, duh.
Snappers are world objects that only appear when editing, that are studded with snap points.
Since snappers often overlap with objects (no collisions!) there needs to be a way to separate grab-targets...
* separate "grab" for snappers and other objects?
* move overlapping points apart when the cursor is near more than one? Maybe with Z-shear effect?
  * I don't like targets that move when you hover.
  * so maybe make a deliberate z-shear
- snap menu
  - maybe a triangle of square grids, from 1x1 to 1x9 to 9x9
  - also some circles with a stud in the middle and studs at the edge: 3, 5, 6 (hex grid?!), 7, 9, 12, 16, 32, 64?
  - maybe shorter arcs too
- top-level switch to toggle snapping on/off? I can see it getting annoying when you're doing free-form dragging.


Polygons (this will wreck my world so do at own risk)
- physics
  - represent segment
  - primitive static segment vs circle collision detection
  - represent concave polygon as complex body, lists of primitives with postion offsets
    - segments
    - corners
  - util for collapsing corners and segments of multiple convex into concave polys.
    - cull in-pointing corners
    - cull inner segments
- rendering
  - divide concave poly into convex chunks
- editing - polygrid, each tile containing N convex polys
  - bisect op
  - cut corner op
  - add - leave no overlap
  - subtract - use cut and bisect


Multiplayer
* up to four touch players
* Up to three keyboard players: wasd, ijkl, arrows
* Gamepad controls if possible
Player modes: Absent, Wispy, Embodied

chain constraints
Simple distance between two body positions - no offset from center, because rotation would make that harder...
Or allow off-center chain points, but only for short chains that never bend more than 90 degrees. Then
approximate angular motion as linear motion and solve for constraint-violation time that way. Guaranteed to remain
in-bounds, I think.
- jack data
- jack rendering
- link data
- link rendering
- editor
  - jack hover indicators
  - link-creation button
    - link type determined by jack type
  - link hover indicators
  - link deletion

Zoomable Editor
- two-touch pinch/unpinch
- mouse onscroll, like Vorp
- keys, maybe "[" and "]" or "," and "."
- Touching the zoom indicator buttons zooms to that level Maybe four: close, medium, wide, far.
